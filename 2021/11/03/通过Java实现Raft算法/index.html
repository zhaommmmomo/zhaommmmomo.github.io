<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>通过Java实现Raft算法 - zmm&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="zhaommmmomo"><meta name="msapplication-TileImage" content="/img/logo.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="zhaommmmomo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言7月份的时候参加了一个阿里天池的性能优化比赛，后面在复赛的时候因为是集群场景，需要考虑各个节点之间数据的一致性，本来想自己实现的，但奈何时间太短（ps: 太菜了😭），最终还是找了市面上成熟的中间件来实现（Ignite）。这不，还是手痒，自己实现一个基于Raft的一致性服务。 Github：zraft 个人博客：zhaommmmomo"><meta property="og:type" content="blog"><meta property="og:title" content="通过Java实现Raft算法"><meta property="og:url" content="http://zhaommmmomo.cn/2021/11/03/%E9%80%9A%E8%BF%87Java%E5%AE%9E%E7%8E%B0Raft%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="zmm&#039;s blog"><meta property="og:description" content="前言7月份的时候参加了一个阿里天池的性能优化比赛，后面在复赛的时候因为是集群场景，需要考虑各个节点之间数据的一致性，本来想自己实现的，但奈何时间太短（ps: 太菜了😭），最终还是找了市面上成熟的中间件来实现（Ignite）。这不，还是手痒，自己实现一个基于Raft的一致性服务。 Github：zraft 个人博客：zhaommmmomo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/83bcda9283f1406da02a959fd41513b8.png#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/2cf5f095532b468eaac9745277b3a2b1.png#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/26d66796538449c79def94b178f38008.png#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/1c3ecc44b48e4c98ba95afb371da216d.png#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/1b78a00d87e44195a208197bd16d63ce.png#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/bc6bc9a94adc44e9b7ededac6c8d4b43.png#pic_center"><meta property="article:published_time" content="2021-11-03T02:24:23.000Z"><meta property="article:modified_time" content="2021-11-25T14:03:47.147Z"><meta property="article:author" content="zhaommmmomo"><meta property="article:tag" content="Java"><meta property="article:tag" content="算法"><meta property="article:tag" content="分布式"><meta property="article:tag" content="一致性协议"><meta property="article:tag" content="实现"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://img-blog.csdnimg.cn/83bcda9283f1406da02a959fd41513b8.png#pic_center"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://zhaommmmomo.cn/2021/11/03/%E9%80%9A%E8%BF%87Java%E5%AE%9E%E7%8E%B0Raft%E7%AE%97%E6%B3%95/"},"headline":"通过Java实现Raft算法","image":[],"datePublished":"2021-11-03T02:24:23.000Z","dateModified":"2021-11-25T14:03:47.147Z","author":{"@type":"Person","name":"zhaommmmomo"},"publisher":{"@type":"Organization","name":"zmm's blog","logo":{"@type":"ImageObject","url":"http://zhaommmmomo.cn/img/logo.jpg"}},"description":"前言7月份的时候参加了一个阿里天池的性能优化比赛，后面在复赛的时候因为是集群场景，需要考虑各个节点之间数据的一致性，本来想自己实现的，但奈何时间太短（ps: 太菜了😭），最终还是找了市面上成熟的中间件来实现（Ignite）。这不，还是手痒，自己实现一个基于Raft的一致性服务。 Github：zraft 个人博客：zhaommmmomo"}</script><link rel="canonical" href="http://zhaommmmomo.cn/2021/11/03/%E9%80%9A%E8%BF%87Java%E5%AE%9E%E7%8E%B0Raft%E7%AE%97%E6%B3%95/"><link rel="alternate" href="/atom.xml" title="zmm&#039;s blog" type="application/atom+xml"><link rel="icon" href="/img/logo.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="zmm&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/books">书架</a><a class="navbar-item" href="/paper">论文</a><a class="navbar-item" href="/resume">个人简历</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://www.github.com/zhaommmmomo"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-03T02:24:23.000Z" title="11/3/2021, 10:24:23 AM">2021-11-03</time>发表</span><span class="level-item"> zhaommmmomo </span><span class="level-item"><a class="link-muted" href="/categories/Code/">Code</a><span> / </span><a class="link-muted" href="/categories/Code/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span> / </span><a class="link-muted" href="/categories/Code/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8D%8F%E8%AE%AE/">协议</a><span> / </span><a class="link-muted" href="/categories/Code/%E5%AE%9E%E7%8E%B0/">实现</a><span> / </span><a class="link-muted" href="/categories/Code/%E5%AE%9E%E7%8E%B0/%E7%AE%97%E6%B3%95/">算法</a></span><span class="level-item">26 分钟读完 (大约3929个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">通过Java实现Raft算法</h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>7月份的时候参加了一个阿里天池的性能优化比赛，后面在复赛的时候因为是集群场景，需要考虑各个节点之间数据的一致性，本来想自己实现的，但奈何时间太短（ps: 太菜了😭），最终还是找了市面上成熟的中间件来实现（Ignite）。这不，还是手痒，自己实现一个基于Raft的一致性服务。</p>
<p>Github：<a target="_blank" rel="noopener" href="https://github.com/zhaommmmomo/zraft">zraft</a></p>
<p>个人博客：<a href="http://zhaommmmomo.cn/">zhaommmmomo</a></p>
<span id="more"></span>

<br>

<br>

<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><strong>Raft是一个为了管理复制日志的一致性算法</strong>。它提供和Paxos算法相同的功能和性能，但是它的算法结构与Paxos不同并且更加易于理解</p>
<p>Raft 通过选举一个Leader，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。<strong>数据的流向只能是Leader -&gt; otherNode</strong>。</p>
<br>

<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p><img src="https://img-blog.csdnimg.cn/83bcda9283f1406da02a959fd41513b8.png#pic_center"></p>
<p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<p>一致性算法的任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。</p>
<p>实际系统中使用的一致性算法通常含有以下特性：</p>
<ul>
<li>安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、重复和乱序等错误都可以保证正确。</li>
<li>可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。它们稍后可能会从可靠存储的状态中恢复并重新加入集群。</li>
<li>不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li>
<li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li>
</ul>
<br>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><p><img src="https://img-blog.csdnimg.cn/2cf5f095532b468eaac9745277b3a2b1.png#pic_center"></p>
<ul>
<li><strong>Leader</strong>：负责处理所有Client请求，并将entries通过AppendEntries()RPC方法添加到其他节点去。</li>
<li><strong>Candidate</strong>：可以变为Leader的节点。当某一段时间内没有收到心跳或者收到的大多数票数时，就会变为Leader，给其他节点发送心跳。否则变为Follower</li>
<li><strong>Follower</strong>：只响应来自其他服务器的请求。集群刚启动时，所有节点状态都是Follower，当某一段时间内没有收到其他节点的信息，就会变为Candidate并向其他节点请求投票。</li>
</ul>
<br>

<h4 id="任期（term）"><a href="#任期（term）" class="headerlink" title="任期（term）"></a>任期（term）</h4><p><img src="https://img-blog.csdnimg.cn/26d66796538449c79def94b178f38008.png#pic_center"></p>
<p>Raft将<strong>任期（term）</strong>作为逻辑时间。任期自增的整数表示（初始为0）。每一段任期从一次<strong>选举</strong>开始，如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，<strong>这一任期会以没有领导人结束</strong>；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导人。</p>
<br>

<h4 id="选举方法（RequestVote-）"><a href="#选举方法（RequestVote-）" class="headerlink" title="选举方法（RequestVote()）"></a>选举方法（RequestVote()）</h4><ul>
<li>如果term &lt; currentTerm返回 false</li>
<li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VoteResponse <span class="title">requestVote</span><span class="params">(VoteRequest voteRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果term &lt; currentTerm返回 false</span></span><br><span class="line">    <span class="comment">// 如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他</span></span><br><span class="line">&#125;</span><br><span class="line">Class VoteRequest &#123;</span><br><span class="line">    <span class="comment">/** 候选人的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** 候选人Id */</span></span><br><span class="line">    <span class="keyword">long</span> candidateId;</span><br><span class="line">    <span class="comment">/** 候选人的最后日志条目的索引值 */</span></span><br><span class="line">    <span class="keyword">long</span> lastLogIndex;</span><br><span class="line">    <span class="comment">/** 候选人最后日志条目的任期号 */</span></span><br><span class="line">	<span class="keyword">long</span> lastLogTerm</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoteResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 当前节点的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** 是否投票 */</span></span><br><span class="line">    <span class="keyword">boolean</span> voteGranted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群刚启动的时候，所有节点都是Follower状态。如果Follower在选举超时内每收到心跳或者投票请求，它就会进行选举投票，先增加自己的任期号并转换为Candidate，然后向其他节点发送RPC投票请求。</p>
<ol>
<li>获得了大多数的选票。修改状态为Leader，修改维护的<code>nextIndex[]</code>数组为当前日志条目的索引，关闭等待超时计时器，开启心跳计时器并发送心跳包。</li>
<li>其他节点成为Leader。如果Leader的任期号不小于当前任期号，修改状态为Follower。</li>
<li>出现同票情况。<strong>随机生成超时时间</strong>后重新开始新一轮的选举。</li>
</ol>
<br>

<h4 id="追加条目（AppendEntries-）"><a href="#追加条目（AppendEntries-）" class="headerlink" title="追加条目（AppendEntries()）"></a>追加条目（AppendEntries()）</h4><p>只能由Leader -&gt; 其他节点，不能到Leader，是单向的。</p>
<p>Client发送RPC请求，Leader首先会将日志追加到本地，追加失败则返回false。然后通过AppendEntries()方法同步到其他节点上去，当Leader收到大多数节点响应true时，会将该日志条目Commit，然后将结果返回给Client，然后通知其他节点Commit。</p>
<p><img src="https://img-blog.csdnimg.cn/1c3ecc44b48e4c98ba95afb371da216d.png#pic_center"></p>
<p>当追加的条目为空时，代表这是个心跳包</p>
<ul>
<li>如果当前任期大于请求任期，返回false</li>
<li>如果当前日志条目没有能够与preLogIndex和preLogTerm匹配的，返回false</li>
<li>重置等待计时器等待时间</li>
<li>如果发生条目冲突（索引相同，任期不同），删除冲突索引以后的所有日志</li>
<li>追加日志条目</li>
<li>如果Leader的commitIndex大于本地的，将本地的设置为min(commitIndex. logIndex) </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendResponse <span class="title">appendEntries</span><span class="params">(AppendRequest appendRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前任期大于请求任期，返回false</span></span><br><span class="line">    <span class="comment">// 如果当前日志条目没有能够与preLogIndex和preLogTerm匹配的，返回false</span></span><br><span class="line">    <span class="comment">// 重置等待计时器等待时间</span></span><br><span class="line">    <span class="comment">// 如果发生条目冲突（索引相同，任期不同），删除冲突索引以后的所有日志</span></span><br><span class="line">	<span class="comment">// 追加日志条目</span></span><br><span class="line">    <span class="comment">// 如果Leader的commitIndex大于本地的，将本地的设置为min(commitIndex. logIndex)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Leader的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** LeaderId */</span></span><br><span class="line">    <span class="keyword">long</span> leaderId;</span><br><span class="line">    <span class="comment">/** 新日志的前一个日志条目的索引 */</span></span><br><span class="line">    <span class="keyword">long</span> preLogIndex;</span><br><span class="line">    <span class="comment">/** 新日志的前一个日志条目的任期号 */</span></span><br><span class="line">	<span class="keyword">long</span> preLogTerm;</span><br><span class="line">    <span class="comment">/** 需要添加的条目信息 */</span></span><br><span class="line">    List&lt;Entry&gt; entries;</span><br><span class="line">    <span class="comment">/** Leader的提交索引 */</span></span><br><span class="line">	<span class="keyword">long</span> leaderCommit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** 命令 */</span></span><br><span class="line">    String command;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 当前节点的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** Follower的条目是否与Leader的匹配上了 */</span></span><br><span class="line">    <span class="keyword">boolean</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Leader对于每个Follower都维护 一个<code>nextIndex</code>，记录需要给该Follower发送的下一个日志条目的索引。当某一个节点刚成为Leader时，它会将所有<code>nextIndex</code>设置为自己的最后一个日志的<code>index + 1</code>。如果一个Follower的日志和Leader不一致，那么在下一次的<code>AppendEntries()</code> RPC 时的一致性检查就会失败。在被Follower拒绝之后，Leader就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得Leader和Follower的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把Follower冲突的日志条目全部删除并且加上Leader的日志。一旦附加日志 RPC 成功，那么Follower的日志就会和Leader保持一致，并且在接下来的任期里一直继续保持。</p>
<br>

<br>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="核心类图"><a href="#核心类图" class="headerlink" title="核心类图"></a>核心类图</h3><p><img src="https://img-blog.csdnimg.cn/1b78a00d87e44195a208197bd16d63ce.png#pic_center"></p>
<br>

<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="requestVote"><a href="#requestVote" class="headerlink" title="requestVote()"></a>requestVote()</h4><ul>
<li>如果候选人的term &lt; currentTerm，不给该候选人投票</li>
<li>如果当前节点没有投票或者投给了候选人并且候选人日志和当前节点一样新，就给该候选人投票</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/bc6bc9a94adc44e9b7ededac6c8d4b43.png#pic_center"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点选举</span></span><br><span class="line"><span class="comment"> * 选举超时：Follower等待成为Leader的时间，随机设置在150ms ~ 300ms</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           &#123;</span></span><br><span class="line"><span class="comment"> *                              term:           候选人任期号</span></span><br><span class="line"><span class="comment"> *                              candidateId:    候选人Id</span></span><br><span class="line"><span class="comment"> *                              lastLogIndex:   候选人最好的日志条目索引值</span></span><br><span class="line"><span class="comment"> *                              lastLogTerm:    候选人最后日志条目的任期号</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> * ZRaftResponse            &#123;</span></span><br><span class="line"><span class="comment"> *                              &quot;term&quot;:         当前任期号</span></span><br><span class="line"><span class="comment"> *                              &quot;voteGranted&quot;:  true / false</span></span><br><span class="line"><span class="comment"> *                                              是否被投票</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestVote</span><span class="params">(VoteRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                        StreamObserver&lt;ZRaftResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当节点收到比自己大的任期，会将自己的任期设置为相同的，然后直接投票</span></span><br><span class="line">    <span class="comment">// 当节点收到和自己一样大的任期，会看自己是否已经投票来判断</span></span><br><span class="line">    ZRaftResponse response = ZRaftResponse.newBuilder()</span><br><span class="line">                                    .setTerm(NodeManager.node.getCurrentTerm())</span><br><span class="line">                                    .setSuccess(vote(request))</span><br><span class="line">                                    .build();</span><br><span class="line"></span><br><span class="line">    responseObserver.onNext(response);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前节点是否投票给候选人</span></span><br><span class="line"><span class="comment"> * 如果候选人的term &lt; currentTerm，不给该候选人投票</span></span><br><span class="line"><span class="comment"> * 如果当前节点没有投票或者投给了候选人并且候选人日志和当前节点一样新，就给该候选人投票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           候选人id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>                  true / false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">vote</span><span class="params">(VoteRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> term = request.getTerm();</span><br><span class="line">    <span class="keyword">long</span> currentTerm = NodeManager.node.getCurrentTerm();</span><br><span class="line">    <span class="keyword">if</span> (term &lt; currentTerm) &#123;</span><br><span class="line">        <span class="comment">// 如果请求者任期小于当前节点任期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (term &gt; currentTerm) &#123;</span><br><span class="line">        <span class="comment">// 更新等待定时器的时间</span></span><br><span class="line">        NodeManager.electionListener</span><br><span class="line">            .updatePreHeartTime(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// 修改节点任期信息</span></span><br><span class="line">        zRaftService.updateNodeTermInfo(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> votedFor = NodeManager.node.getVotedFor();</span><br><span class="line">    <span class="keyword">long</span> candidateId = request.getCandidateId();</span><br><span class="line">    <span class="keyword">if</span> (votedFor == <span class="number">0</span> ||</span><br><span class="line">        (votedFor == candidateId &amp;&amp;</span><br><span class="line">         NodeManager.node.getLogIndex() == request.getLastLogIndex() &amp;&amp;</span><br><span class="line">         NodeManager.node.getLastLogTerm() == request.getLastLogTerm())) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有投票或者</span></span><br><span class="line">        <span class="comment">// 给请求者投票了并且日志索引与任期能对应</span></span><br><span class="line">        <span class="comment">// 更新等待定时器的时间</span></span><br><span class="line">        NodeManager.electionListener</span><br><span class="line">            .updatePreHeartTime(System.currentTimeMillis());</span><br><span class="line">        NodeManager.node.setLeaderId(<span class="number">0</span>);</span><br><span class="line">        NodeManager.node.setVotedFor(candidateId);</span><br><span class="line">        NodeManager.printNodeInfo();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="appendEntries"><a href="#appendEntries" class="headerlink" title="appendEntries()"></a>appendEntries()</h4><ol>
<li>Leader接收到数据更改，将更改添加到节点日志中（不提交）</li>
<li>将该条目复制到Follower，等待回复，直到大多数（n / 2 + 1）节点响应成功。如果没有超过半数的节点响应成功，隔段超时时间后重新发送。</li>
<li>Leader提交数据，然后将结果返回给并通知Follower进行提交</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 追加条目，心跳，节点间数据的同步，日志复制</span></span><br><span class="line"><span class="comment"> * 1. Leader接收到数据更改，将更改添加到节点日志中（不提交）</span></span><br><span class="line"><span class="comment"> * 2. 将该条目复制到Follower，等待回复，直到大多数（n / 2 + 1）</span></span><br><span class="line"><span class="comment"> *    节点响应成功。如果没有超过半数的节点响应成功，隔段超时时间后重新发送</span></span><br><span class="line"><span class="comment"> * 3. Leader提交数据，然后将结果返回给并通知Follower进行提交</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           &#123;</span></span><br><span class="line"><span class="comment"> *                              term:           Leader任期</span></span><br><span class="line"><span class="comment"> *                              leaderId:       有时候可能是Candidate收到请求，</span></span><br><span class="line"><span class="comment"> *                                              需要将请求重定向到Leader去</span></span><br><span class="line"><span class="comment"> *                              preLogIndex:    前一个日志条目的索引</span></span><br><span class="line"><span class="comment"> *                              preLogTerm:     前一个日志条目的任期</span></span><br><span class="line"><span class="comment"> *                              entries:        需要被保存的日志条目（如果为空，代表是心跳）</span></span><br><span class="line"><span class="comment"> *                              leaderCommit:   Leader已提交的最高日志条目的索引</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> * ZRaftResponse            &#123;</span></span><br><span class="line"><span class="comment"> *                              &quot;term&quot;:         当前任期</span></span><br><span class="line"><span class="comment"> *                              &quot;success&quot;:      true / false。如果Candidate</span></span><br><span class="line"><span class="comment"> *                                              所含有的条目和prevLogIndex以及preLogTerm</span></span><br><span class="line"><span class="comment"> *                                              匹配上，则为true。</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendEntries</span><span class="params">(AppendRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                          StreamObserver&lt;ZRaftResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    NodeManager.printLog(<span class="string">&quot;appendEntries...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZRaftResponse.Builder builder = ZRaftResponse.newBuilder()</span><br><span class="line">            .setTerm(NodeManager.node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果currentTerm &gt; term</span></span><br><span class="line">    <span class="keyword">long</span> term = request.getTerm();</span><br><span class="line">    <span class="keyword">long</span> currentTerm = NodeManager.node.getCurrentTerm();</span><br><span class="line">    <span class="keyword">if</span> (term &lt; currentTerm) &#123;</span><br><span class="line">        <span class="comment">// 返回false</span></span><br><span class="line">        builder.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        responseObserver.onNext(builder.build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新等待计时器</span></span><br><span class="line">    NodeManager.electionListener</span><br><span class="line">            .updatePreHeartTime(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果term &gt; currentTerm 或者当前节点状态是Candidate</span></span><br><span class="line">    Node.NodeState state = NodeManager.node.getNodeState();</span><br><span class="line">    <span class="keyword">if</span> (term &gt; currentTerm || state == Node.NodeState.CANDIDATE) &#123;</span><br><span class="line">        <span class="comment">// 修改任期状态并切换为Follower</span></span><br><span class="line">        zRaftService.levelDown(request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置LeaderId</span></span><br><span class="line">        <span class="keyword">long</span> leaderId = NodeManager.node.getLeaderId();</span><br><span class="line">        <span class="keyword">if</span> (leaderId == <span class="number">0</span>) &#123;</span><br><span class="line">            NodeManager.node.setLeaderId(request.getLeaderId());</span><br><span class="line">            NodeManager.node.setNodeState(Node.NodeState.FOLLOWER);</span><br><span class="line">            NodeManager.printNodeInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> preLogTerm = request.getPreLogTerm();</span><br><span class="line">    <span class="keyword">long</span> preLogIndex = request.getPreLogIndex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果Leader日志索引不能在当前节点的索引上找到</span></span><br><span class="line">    <span class="keyword">if</span> (!NodeManager.node.entryIsExist(preLogTerm, preLogIndex)) &#123;</span><br><span class="line">        <span class="comment">// 返回false</span></span><br><span class="line">        builder.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        responseObserver.onNext(builder.build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是心跳包</span></span><br><span class="line">    List&lt;Entry&gt; entries = request.getEntriesList();</span><br><span class="line">    <span class="keyword">if</span> (entries.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 添加日志条目</span></span><br><span class="line">        b = NodeManager.node.addLogEntries(preLogIndex, entries);</span><br><span class="line">        NodeManager.printLog(NodeManager.node.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否要提交条目</span></span><br><span class="line">    <span class="keyword">long</span> leaderCommit = request.getLeaderCommit();</span><br><span class="line">    <span class="keyword">long</span> commitIndex = NodeManager.node.getCommitIndex();</span><br><span class="line">    <span class="keyword">if</span> (leaderCommit &gt; commitIndex) &#123;</span><br><span class="line">        <span class="comment">// 将提交</span></span><br><span class="line">        b = NodeManager.node.commitLog(leaderCommit) &amp;&amp; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builder.setSuccess(b);</span><br><span class="line">    responseObserver.onNext(builder.build());</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="sendCommand"><a href="#sendCommand" class="headerlink" title="sendCommand()"></a>sendCommand()</h4><p>客户端调用的RPC方法。</p>
<p>如果当前节点是Leader:</p>
<ul>
<li>第一阶段，将指令保存在log条目中，给其他节点发送AppendEntries，异步等待消息。</li>
<li>第二阶段，当大多数节点返回true，在本地进行提交并将结果返回给用户，同时向其他节点发送提交命令.</li>
</ul>
<p>如果当前节点是Follower:</p>
<ul>
<li>将该请求重定向到Leader去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用的RPC方法。</span></span><br><span class="line"><span class="comment"> * 如果当前节点是Leader:</span></span><br><span class="line"><span class="comment"> *    第一阶段，将指令保存在log条目中，给其他节点发送AppendEntries，异步等待消息。</span></span><br><span class="line"><span class="comment"> *    第二阶段，当大多数节点返回true，在本地进行提交并将结果返回给用户，同时向其他节点</span></span><br><span class="line"><span class="comment"> *    发送提交命令.</span></span><br><span class="line"><span class="comment"> * 如果当前节点是Follower:</span></span><br><span class="line"><span class="comment"> *    将该请求重定向到Leader去。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           指令集（字符串list）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCommand</span><span class="params">(Command request, StreamObserver&lt;ClientResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    ProtocolStringList commandList = request.getCommandList();</span><br><span class="line">    ClientResponse.Builder builder = ClientResponse.newBuilder();</span><br><span class="line">    <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> size = commandList.size();</span><br><span class="line">    Node.NodeState state = NodeManager.node.getNodeState();</span><br><span class="line">    <span class="keyword">long</span> leaderId = NodeManager.node.getLeaderId();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> || state != Node.NodeState.LEADER) &#123;</span><br><span class="line">        <span class="comment">// 如果用户没有发送条目或者当前节点不是Leader，直接返回false并添加LeaderId</span></span><br><span class="line">        responseObserver.onNext(builder.setSuccess(b).setLeaderId(leaderId).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理该请求</span></span><br><span class="line">    <span class="comment">// 第一阶段，保存指令到本地并给其他节点发送消息</span></span><br><span class="line">    <span class="keyword">long</span> currentTerm = NodeManager.node.getCurrentTerm();</span><br><span class="line">    List&lt;Entry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String command : commandList) &#123;</span><br><span class="line">        Entry entry = Entry.newBuilder()</span><br><span class="line">                           .setTerm(currentTerm)</span><br><span class="line">                           .setCommand(command)</span><br><span class="line">                           .build();</span><br><span class="line">        entries.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!NodeManager.node.addLogEntries(entries)) &#123;</span><br><span class="line">        <span class="comment">// 如果本地添加条目失败，返回false</span></span><br><span class="line">        responseObserver.onNext(builder.setSuccess(b).setLeaderId(leaderId).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将返回交给AppendFutureListener</span></span><br><span class="line">    AppendFutureListener.responseObserver = responseObserver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送RPC请求</span></span><br><span class="line">    zRaftService.sendAppendEntries(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft论文</a></p>
<p><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft">Raft动态展示</a></p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT6.824</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>通过Java实现Raft算法</p><p><a href="http://zhaommmmomo.cn/2021/11/03/通过Java实现Raft算法/">http://zhaommmmomo.cn/2021/11/03/通过Java实现Raft算法/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>zhaommmmomo</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Attribution" href="http://zhaommmmomo.cn"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Download on GitHub" href="https://github.com/zhaommmmomo/blog"><i class="icon fab fa-github"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><a class="link-muted mr-2" rel="tag" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/">一致性协议</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%AE%9E%E7%8E%B0/">实现</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/07/%E3%80%90%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E3%80%91%E4%BA%91%E4%B8%8A%E5%BC%80%E5%8F%91%EF%BC%8C%E9%AB%98%E6%95%88%E6%99%BA%E8%83%BD%E2%80%93%E9%98%BF%E9%87%8C%E4%BA%91ECS%20Cloudbuild%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E8%B5%9B%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E9%81%93/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">【比赛复盘】云上开发，高效智能–阿里云ECS Cloudbuild开发者大赛性能挑战赛道</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/14/Icarus%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"><span class="level-item">Icarus主题的一些常用配置</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/logo.jpg" alt="zhaommmmomo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zhaommmmomo</p><p class="is-size-6 is-block">fahaxiki!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Yantai,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://zhaommmmomo.cn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zhaommmmomo"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#Raft"><span class="level-left"><span class="level-item">2</span><span class="level-item">Raft</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#是什么？"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">是什么？</span></span></a></li><li><a class="level is-mobile" href="#状态机"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">状态机</span></span></a></li><li><a class="level is-mobile" href="#概念"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">概念</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#节点状态"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">节点状态</span></span></a></li><li><a class="level is-mobile" href="#任期（term）"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">任期（term）</span></span></a></li><li><a class="level is-mobile" href="#选举方法（RequestVote-）"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">选举方法（RequestVote()）</span></span></a></li><li><a class="level is-mobile" href="#追加条目（AppendEntries-）"><span class="level-left"><span class="level-item">2.3.4</span><span class="level-item">追加条目（AppendEntries()）</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#实现"><span class="level-left"><span class="level-item">3</span><span class="level-item">实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#核心类图"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">核心类图</span></span></a></li><li><a class="level is-mobile" href="#核心方法"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">核心方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#requestVote"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">requestVote()</span></span></a></li><li><a class="level is-mobile" href="#appendEntries"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">appendEntries()</span></span></a></li><li><a class="level is-mobile" href="#sendCommand"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">sendCommand()</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">4</span><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="zmm&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 zhaommmmomo</span>  <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">湘ICP备案2021018362号</a>    <a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43062302000147">湘公网安备43062302000147号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/zhaommmmomo"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>