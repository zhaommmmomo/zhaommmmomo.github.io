<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zmm&#39;s blog</title>
  
  
  <link href="http://zhaommmmomo.cn/atom.xml" rel="self"/>
  
  <link href="http://zhaommmmomo.cn/"/>
  <updated>2022-02-10T05:35:15.838Z</updated>
  <id>http://zhaommmmomo.cn/</id>
  
  <author>
    <name>zhaommmmomo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SkipList原理及实现</title>
    <link href="http://zhaommmmomo.cn/2021/12/04/SkipList%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhaommmmomo.cn/2021/12/04/SkipList%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-12-04T02:41:28.000Z</published>
    <updated>2022-02-10T05:35:15.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>randLevel算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis实现</span></span><br><span class="line"><span class="comment"> * 初始层数为1，每次随机生成一个随机数，取低16位</span></span><br><span class="line"><span class="comment"> * 当取的这个值小于0.25倍的0xFFFF时，level++，否则退出。</span></span><br><span class="line"><span class="comment"> * 返回level和maxLevel的最小值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里的ZSKIPLIST_P是晋升的概率。对应的期望层高是E=1/(1-p)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random() &amp; <span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><br><br><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p><a href="http://zhaommmmomo.cn/pdf/%E8%AE%BA%E6%96%87/SkipList.pdf">论文地址</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SkipList是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。</p><p>下图是一个简单的skiplist</p><p><img src="http://zhaommmmomo.cn/img/skiplist1.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>说白了就是一个有序链表加上索引，以空间换时间。</p><br><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node header;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxLevel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class Node &#123;</span><br><span class="line">        <span class="comment">/** 用来保存该节点所记录的层数 */</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;Node&gt; levels;</span><br><span class="line">        <span class="comment">/** 用来保存该节点的数据 */</span></span><br><span class="line">        <span class="keyword">private</span> Entry entry;</span><br><span class="line">        <span class="comment">/** 用来记录该节点的分数 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p><img src="http://zhaommmmomo.cn/img/skiplist1.png"></p><p>如果我们需要查询6这个位置的数据</p><p>skiplist会进行如下查询：</p><ol><li>先从节点1的最高层进行与下一个节点9进行比较，小于节点9，层数降低。</li><li>再将节点1与下一个节点4进行比较，大于节点4，指针指向节点4。</li><li>然后将节点4与节点9进行比较，小于节点9层数降低。</li><li>将节点4与节点6比较，这时候找到了需要查询的节点，进行返回。</li></ol><p>（如果层数的最低层并且没找到就返回null）</p><p><img src="http://zhaommmmomo.cn/img/skiplist2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] get(<span class="keyword">byte</span>[] key) &#123;</span><br><span class="line">    <span class="comment">// 计算key的分数</span></span><br><span class="line">    <span class="comment">// calcScore()函数类似hash，功能是将key转换为一个对应的float值</span></span><br><span class="line">    <span class="comment">// 方便比较，这样就需要函数比较高效。</span></span><br><span class="line">    <span class="keyword">float</span> score = calcScore(key);</span><br><span class="line">    List&lt;Node&gt; levels = header.levels;</span><br><span class="line">    <span class="comment">// 首先先遍历节点的levels</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Node next = levels.get(i);</span><br><span class="line">        <span class="comment">// 直到当前level的下一个节点的score小于当前的score</span></span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前的score和下一个的进行比较</span></span><br><span class="line">            <span class="keyword">int</span> flag = compare(score, key, next);</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 相同</span></span><br><span class="line">                <span class="keyword">return</span> next.getEntry().value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 小于，下一层</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 大于</span></span><br><span class="line">            <span class="comment">// 从下一个节点开始找</span></span><br><span class="line">            levels = next.levels;</span><br><span class="line">            next = levels.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>与查找的方法类似，但是需要记录查找所经过的节点。 </p><p>如果我们需要添加节点5</p><p><img src="http://zhaommmmomo.cn/img/skiplist3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> score = calcScore(entry.key);</span><br><span class="line">    <span class="comment">// 前继节点</span></span><br><span class="line">    Node[] preNode = <span class="keyword">new</span> Node[level];</span><br><span class="line">    <span class="comment">// 找插入的位置</span></span><br><span class="line">    Node p = header;</span><br><span class="line">    <span class="comment">// 竖着找</span></span><br><span class="line">    <span class="comment">// 遍历节点p的levels</span></span><br><span class="line">    List&lt;Node&gt; levels = p.levels;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 获取该层的next节点</span></span><br><span class="line">        next = levels.get(i);</span><br><span class="line">        <span class="comment">// 横向找，直到下一个分数大于等于当前分数或者下一个为null</span></span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 与当前key进行比较</span></span><br><span class="line">            <span class="keyword">int</span> flag = compare(score, entry.key, next);</span><br><span class="line">            <span class="keyword">if</span> (flag == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 下一层</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 相同，直接修改并返回</span></span><br><span class="line">                size += entry.size() - next.entry.size();</span><br><span class="line">                next.entry = entry;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下一个节点</span></span><br><span class="line">            p = next;</span><br><span class="line">            levels = p.levels;</span><br><span class="line">            next = levels.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加前继节点</span></span><br><span class="line">        preNode[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建新节点</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(entry, score);</span><br><span class="line">    <span class="comment">// 获取新节点层数</span></span><br><span class="line">    <span class="keyword">int</span> cLevel = randLevel();</span><br><span class="line">    <span class="keyword">int</span> minLevel = Math.min(cLevel, level);</span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLevel; i++) &#123;</span><br><span class="line">        Node swap = preNode[i].levels.get(i);</span><br><span class="line">        preNode[i].levels.set(i, newNode);</span><br><span class="line">        newNode.addLevel(swap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否需要增加层数</span></span><br><span class="line">    <span class="keyword">while</span> (cLevel &gt; level) &#123;</span><br><span class="line">        <span class="comment">// 将头节点层数增加</span></span><br><span class="line">        header.levels.add(newNode);</span><br><span class="line">        newNode.addLevel(<span class="keyword">null</span>);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    length++;</span><br><span class="line">    size += entry.size();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;重点&quot;&gt;&lt;a href=&quot;#重点&quot; class=&quot;headerlink&quot; title=&quot;重点&quot;&gt;&lt;/a&gt;重点&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;randLevel算法&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Redis实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 初始层数为1，每次随机生成一个随机数，取低16位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 当取的这个值小于0.25倍的0xFFFF时，level++，否则退出。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 返回level和maxLevel的最小值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 这里的ZSKIPLIST_P是晋升的概率。对应的期望层高是E=1/(1-p)。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZSKIPLIST_MAXLEVEL 64&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZSKIPLIST_P 0.25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;randLevel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; level = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((random() &amp;amp; &lt;span class=&quot;number&quot;&gt;0xFFFF&lt;/span&gt;) &amp;lt; (ZSKIPLIST_P * &lt;span class=&quot;number&quot;&gt;0xFFFF&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        level += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (level &amp;lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="实现" scheme="http://zhaommmmomo.cn/categories/Code/%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="数据结构" scheme="http://zhaommmmomo.cn/categories/Code/%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="实现" scheme="http://zhaommmmomo.cn/tags/%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="数据结构" scheme="http://zhaommmmomo.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【比赛复盘】云上开发，高效智能–阿里云ECS Cloudbuild开发者大赛性能挑战赛道</title>
    <link href="http://zhaommmmomo.cn/2021/11/07/%E3%80%90%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E3%80%91%E4%BA%91%E4%B8%8A%E5%BC%80%E5%8F%91%EF%BC%8C%E9%AB%98%E6%95%88%E6%99%BA%E8%83%BD%E2%80%93%E9%98%BF%E9%87%8C%E4%BA%91ECS%20Cloudbuild%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E8%B5%9B%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E9%81%93/"/>
    <id>http://zhaommmmomo.cn/2021/11/07/%E3%80%90%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E3%80%91%E4%BA%91%E4%B8%8A%E5%BC%80%E5%8F%91%EF%BC%8C%E9%AB%98%E6%95%88%E6%99%BA%E8%83%BD%E2%80%93%E9%98%BF%E9%87%8C%E4%BA%91ECS%20Cloudbuild%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E8%B5%9B%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E9%81%93/</id>
    <published>2021-11-07T13:35:33.000Z</published>
    <updated>2021-11-26T03:58:17.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快暑假的时候，在阿里天池上面闲逛。诶，性能优化挑战赛？点进去看看，初略的读了一下赛题，要实现一个聊天室服务，部署在ECS服务器上面，然后对它进行一下手段的性能优化，感觉还挺合适的（ps: 当时因为写了一个秒杀系统并压测优化过、也看过一些性能调优的书，感觉自己很nb，后面才知道自己还是太嫩了🤣），顿时就报名了。</p><p>因为第一次参加这种比赛，所以给自己定的是前50就ok了。然后一个月的初赛，快结束的那一周排名十多名，感觉自己还是很厉害的，但是就一周的时间，看着自己排名直接跌出前 20，到了 23。才意识到自己高兴太早了。</p><p>接下来是一个月的复赛时间，这回是要实现一个集群了。中途遇到了老多问题，找了好多官网文档（<a href="https://vertx.io/">Vertx</a>、<a href="https://hazelcast.com/">Hazelcast</a>、<a href="https://www.ignite-service.cn/doc/java/QuickStartGuide.html">Ignite</a>、<a href="https://github.com/google/leveldb">LevelDB</a>），也学到了不少，但还是感觉差点火候😅。每天早上七点多起床一直调试到晚上十点左右，官方人员都被烦的不要不要的了😂（希望不要厌烦）。还是太菜了哈哈哈。</p><p>不多说了，先上排名。</p><p><img src="http://zhaommmmomo.cn/img/tiamchiecs.png"></p><span id="more"></span><br><br><h2 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h2><p><strong>背景</strong>：基于公共云构建产品、系统和应用已经是当前最热门的技术趋势了。赛题探讨Web Service在云上部署的性能优化，希望参赛者通过代码撰写、操作系统与数据库选型、各种参数调优等手段，优化云端Web服务的性能和保障服务的高可用。</p><p><strong>描述</strong>：根据给定的API完成：用户注册、用户登录、创建房间、查看房间、用户进入、退出实时聊天房间、用户发言和实时收取其他人的消息。注：聊天室、消息和用户，三个数据必须持久化；在线人数无须持久化。需要保证程序返回时宕机，数据还存在，允许很少的丢失。三台服务器。</p><p><strong>机器规格</strong>：4 核 8 G</p><p><strong>评分</strong>：能测试的综合得分= n ∗ 10 + 50 ∗ (qps / 10000) ∗ k + 50 ∗ (1 / time_deplay) ∗ m。</p><br><br><h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>一开始系统的架构采用的是Springboot + redis（用了MySQL，直接没出分😅）。写完程序后提交，纳尼？居然才拿到了简单的API正常分（190）？立马打开Jprofiler开始监控，发现压测的时候线程数只有几十个并且线程大多都处于等待状态，而且<code>CPU利用率很低</code>。ok，提高<code>tomcat的线程数</code>（因为Springboot是内嵌tomcat的，而且一个请求会有一个线程去处理），不断的调整，最后找到最优的线程数。鸡冻！立马打开提交界面开始提交，过了几分钟，QPS得分提高 5 分？？？怎么才 5 分？我测了这么久！算了算了，提高了就好。</p><p>但是接下来一段时间，陷入艰难的时刻了，不断的修改、提交，但是分数老是上不去。不行不行，不能就这样下去，大概在网上找了好几天，期间都差点想去学C++的<a href="http://seastar.io/">seastar</a>，后面在<a href="https://www.techempower.com/benchmarks/">techempower</a>网站上找到了性能较高的web容器Vertx，终于看见了曙光。花了 3 ~ 5 天去熟悉Vertx一个个的demo，后面根据需要然后不断的找文档、加功能，一个webserver弄好了！（不得不说，Vertx的文档是我见过最容易懂的，学的最快的）先点个提交看看，300+！芜湖。</p><br><h4 id="同步模型"><a href="#同步模型" class="headerlink" title="同步模型"></a>同步模型</h4><p>像传统的Springboot就是同步模型（其实是tomcat），收到一个请求后，就用一个线程去处理，只能处理一个，其他线程就可能会被阻塞，这样就会大大的降低系统的吞吐量。虽然tomcat后面也支持NIO以及AIO，但是在比赛初期的时候使用了但是效果不太明显，就舍弃了。</p><br><h4 id="多路复用模型"><a href="#多路复用模型" class="headerlink" title="多路复用模型"></a>多路复用模型</h4><p>像我们知道的Linux中的select、poll和epoll，又或者是Redis中的，都是使用的IO多路复用。Vertx正是使用了这种模型，它通过一个Event Loop组不断的循环，当有Event到达时，它会调用相应的handle去处理。这就使得它相比于同步模型有着天然的性能优势，能够处理更多的请求。注意：不要在Event Loop运行时间较长的代码，Vertx有专门用于处理耗时长的代码线程（Worker Verticle）。</p><p><img src="http://zhaommmmomo.cn/img/vertx-thread.png"></p><br><h3 id="线程数"><a href="#线程数" class="headerlink" title="线程数"></a>线程数</h3><p>我们前面说到Vertx是通过一个Event Loop组来不断的循环以及Worker Verticle来处理阻塞代码，但是它们的线程数量应该如何去设置呢？我的思路：<code>Event Loop因为是不断循环的，线程数应和CPU核数差不多。而Worker Verticle处理阻塞代码，可以尽可能的多</code>。最终经过不断的benchmark，调整线程数，最终提高的大概 50 多分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: io.vertx.core.Launcher</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeStartingVertx</span><span class="params">(VertxOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置EventLoop线程池大小</span></span><br><span class="line">    options.setEventLoopPoolSize(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeDeployingVerticle</span><span class="params">(DeploymentOptions deploymentOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置部署多少个Verticle实例</span></span><br><span class="line">    deploymentOptions.setInstances(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>这是另外一个大头。因为以前接触存储这方面比较少，当时认知里面Redis最快，在使用的时候一直开启<code>aof</code>的<code>AOF_FSYNC_ALWAYS</code>，因为赛题要求系统返回就意味着数据罗盘。后面公布可以允许少量的数据丢失后，开启了<code>AOF_FSYNC_EVERYSEC</code>，分数提高了 100 分左右。然后在网上参考一些写性能快的中间件（可能是我没搜引擎之类的，居然没看见<code>LevelDB</code>），后面不知道是哪个博客上面给的测试报告，说<code>MongoDB</code>的写性能优于Redis，然后花了好几天的时间去弄MongoDB和测试，但是在 4 核 8 G的情况下，内存占用太多，并且性能也没Redis好。然后参考了MongoDB的实现，异步定时刷盘。后面就在想自己弄个存储的，直接写，不调中间件了，整个方案是写在内存中然后到达某一阈值 / 时限后异步刷盘，但是测试出来效果都不理想，就给放弃了。后面就是乱找了，像Cassandra、ScyllaDB这些（当时居然没想到看底层是如何实现的了）。</p><p>后面初赛完才了解到<code>LevelDB</code>以及<code>LSM</code>树。详情见：<a href="http://zhaommmmomo.cn/pdf/%E8%AE%BA%E6%96%87/LSM.pdf">LSM论文</a></p><br><h3 id="集群（通信-数据传输）"><a href="#集群（通信-数据传输）" class="headerlink" title="集群（通信 / 数据传输）"></a>集群（通信 / 数据传输）</h3><p>这其实都还挺好弄的，主要是一般以上的节点 ack true 后 response。当时考虑的方案有</p><ul><li>通过分布式缓存实现。像Redis集群，又或者嵌入在程序里面的Hazelcast、Ignite。</li><li>自己实现</li></ul><p>但是当时因为在其他方案上面浪费了很多时间，所以就选择了成熟的实现较快的方案：Ignite。其他方面的原因就是当时想着嵌入在应用程序里面比像Redis额外开一个进程资源消耗低以及网络IO少。但是为什么不选择Hazelcast呢？因为这个东西持久化缓存的话需要 money ！！！</p><p>像这种简单、需求不多、追求性能的场景感觉还是自己实现并且在一个程序里面好点。</p><p>至于数据传输的格式，<a href="https://developers.google.com/protocol-buffers/docs/overview">protobuf</a>就挺不错的，兼容性和性能都挺好。其他的像Json、Xml用的比较多。</p><p>比赛完后实现了一个<a href="http://zhaommmmomo.cn/2021/11/16/%E9%80%9A%E8%BF%87Java%E5%AE%9E%E7%8E%B0Raft%E7%AE%97%E6%B3%95">通过Java实现Raft算法</a>，具体详情移步到该文章。</p><br><h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><p>刚拿到复赛赛题的时候，一开始考虑的是集群每个节点都保存一份完整的数据（ps: 当时想着快速响应，当本地内存中存有数据时，这样最快），后面测试过程中发现查询的效率是挺快的了，但是当集群面临写多的场景下，就出现了很多问题。比如说消息顺序乱（考虑的是时间戳来解决）、集群之间数据同步太慢（主要原因）。后面还是将数据进行了分区存放，集群中每个节点都会存储一块区域的数据，当本地分区没有该数据时，就会去其他分区查询，并可以按需要将查询到的数据缓存到本地，这样做后性能提高了不少。</p><p>但是随之而来的问题就是当存储某一分区的节点宕机之后，其他节点如何访问该分区的数据？</p><p>后面在Ignite官网查看到了<a href="https://www.ignite-service.cn/doc/java/DataRebalancing.html#_1-%E6%95%B0%E6%8D%AE%E5%86%8D%E5%B9%B3%E8%A1%A1">数据再平衡机制</a>。就是会有个中心的节点会管理分区，并将分区分配给集群中的节点，当某一节点宕机后，中心节点就会将宕机后的分区数据流转到其他两个节点上面，这样就解决的数据丢失问题。（因为评测环境不会出现三台服务器都宕机的场景，所以不管如何宕机数据都不会丢失，前提是宕机后的节点重启会先进行数据同步）</p><br><h3 id="Linux可打开的文件数"><a href="#Linux可打开的文件数" class="headerlink" title="Linux可打开的文件数"></a>Linux可打开的文件数</h3><p>这东西感觉还挺常用的哈，具体来说就是连接数的大小，因为Linux都是以fd文件描述符来弄的嘛，所以设置Linux中可以打开的最大文件数可以应对一些connection refuse的场景。具体配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置系统级别的</span></span><br><span class="line">fs.file-max=1100000</span><br><span class="line">fs.nr_open=1100000</span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl -p设置生效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/security/limits.conf</span></span><br><span class="line">soft nofile 1010000</span><br><span class="line">hard nofile 1010000</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：hard nofile 一定要比 fs.nr_open 要小，否则可能会导致用户无法登录</p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>一个好的架构 / 设计（这会帮你省下很多时间）</li><li>技术的广度与深度（你可以快速的找到你所需要的技术）</li><li>学习能力（能够快速熟练的上手某个新的技术）</li><li>心态（放轻松）</li></ol><p>加油！！！</p><br><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><a href="https://tianchi.aliyun.com/forum/postDetail?spm=5176.12586969.1002.3.562c23a2TDr9ZP&postId=307395">复赛第二技术分享</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快暑假的时候，在阿里天池上面闲逛。诶，性能优化挑战赛？点进去看看，初略的读了一下赛题，要实现一个聊天室服务，部署在ECS服务器上面，然后对它进行一下手段的性能优化，感觉还挺合适的（ps: 当时因为写了一个秒杀系统并压测优化过、也看过一些性能调优的书，感觉自己很nb，后面才知道自己还是太嫩了🤣），顿时就报名了。&lt;/p&gt;
&lt;p&gt;因为第一次参加这种比赛，所以给自己定的是前50就ok了。然后一个月的初赛，快结束的那一周排名十多名，感觉自己还是很厉害的，但是就一周的时间，看着自己排名直接跌出前 20，到了 23。才意识到自己高兴太早了。&lt;/p&gt;
&lt;p&gt;接下来是一个月的复赛时间，这回是要实现一个集群了。中途遇到了老多问题，找了好多官网文档（&lt;a href=&quot;https://vertx.io/&quot;&gt;Vertx&lt;/a&gt;、&lt;a href=&quot;https://hazelcast.com/&quot;&gt;Hazelcast&lt;/a&gt;、&lt;a href=&quot;https://www.ignite-service.cn/doc/java/QuickStartGuide.html&quot;&gt;Ignite&lt;/a&gt;、&lt;a href=&quot;https://github.com/google/leveldb&quot;&gt;LevelDB&lt;/a&gt;），也学到了不少，但还是感觉差点火候😅。每天早上七点多起床一直调试到晚上十点左右，官方人员都被烦的不要不要的了😂（希望不要厌烦）。还是太菜了哈哈哈。&lt;/p&gt;
&lt;p&gt;不多说了，先上排名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaommmmomo.cn/img/tiamchiecs.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="复盘" scheme="http://zhaommmmomo.cn/categories/Code/%E5%A4%8D%E7%9B%98/"/>
    
    <category term="比赛" scheme="http://zhaommmmomo.cn/categories/Code/%E5%A4%8D%E7%9B%98/%E6%AF%94%E8%B5%9B/"/>
    
    
    <category term="比赛" scheme="http://zhaommmmomo.cn/tags/%E6%AF%94%E8%B5%9B/"/>
    
    <category term="复盘" scheme="http://zhaommmmomo.cn/tags/%E5%A4%8D%E7%9B%98/"/>
    
    <category term="天池" scheme="http://zhaommmmomo.cn/tags/%E5%A4%A9%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>通过Java实现Raft算法</title>
    <link href="http://zhaommmmomo.cn/2021/11/03/%E9%80%9A%E8%BF%87Java%E5%AE%9E%E7%8E%B0Raft%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaommmmomo.cn/2021/11/03/%E9%80%9A%E8%BF%87Java%E5%AE%9E%E7%8E%B0Raft%E7%AE%97%E6%B3%95/</id>
    <published>2021-11-03T02:24:23.000Z</published>
    <updated>2021-11-25T14:03:47.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>7月份的时候参加了一个阿里天池的性能优化比赛，后面在复赛的时候因为是集群场景，需要考虑各个节点之间数据的一致性，本来想自己实现的，但奈何时间太短（ps: 太菜了😭），最终还是找了市面上成熟的中间件来实现（Ignite）。这不，还是手痒，自己实现一个基于Raft的一致性服务。</p><p>Github：<a href="https://github.com/zhaommmmomo/zraft">zraft</a></p><p>个人博客：<a href="http://zhaommmmomo.cn/">zhaommmmomo</a></p><span id="more"></span><br><br><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><strong>Raft是一个为了管理复制日志的一致性算法</strong>。它提供和Paxos算法相同的功能和性能，但是它的算法结构与Paxos不同并且更加易于理解</p><p>Raft 通过选举一个Leader，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。<strong>数据的流向只能是Leader -&gt; otherNode</strong>。</p><br><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p><img src="https://img-blog.csdnimg.cn/83bcda9283f1406da02a959fd41513b8.png#pic_center"></p><p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p><p>一致性算法的任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。</p><p>实际系统中使用的一致性算法通常含有以下特性：</p><ul><li>安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、重复和乱序等错误都可以保证正确。</li><li>可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。它们稍后可能会从可靠存储的状态中恢复并重新加入集群。</li><li>不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li><li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li></ul><br><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><p><img src="https://img-blog.csdnimg.cn/2cf5f095532b468eaac9745277b3a2b1.png#pic_center"></p><ul><li><strong>Leader</strong>：负责处理所有Client请求，并将entries通过AppendEntries()RPC方法添加到其他节点去。</li><li><strong>Candidate</strong>：可以变为Leader的节点。当某一段时间内没有收到心跳或者收到的大多数票数时，就会变为Leader，给其他节点发送心跳。否则变为Follower</li><li><strong>Follower</strong>：只响应来自其他服务器的请求。集群刚启动时，所有节点状态都是Follower，当某一段时间内没有收到其他节点的信息，就会变为Candidate并向其他节点请求投票。</li></ul><br><h4 id="任期（term）"><a href="#任期（term）" class="headerlink" title="任期（term）"></a>任期（term）</h4><p><img src="https://img-blog.csdnimg.cn/26d66796538449c79def94b178f38008.png#pic_center"></p><p>Raft将<strong>任期（term）</strong>作为逻辑时间。任期自增的整数表示（初始为0）。每一段任期从一次<strong>选举</strong>开始，如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，<strong>这一任期会以没有领导人结束</strong>；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导人。</p><br><h4 id="选举方法（RequestVote-）"><a href="#选举方法（RequestVote-）" class="headerlink" title="选举方法（RequestVote()）"></a>选举方法（RequestVote()）</h4><ul><li>如果term &lt; currentTerm返回 false</li><li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VoteResponse <span class="title">requestVote</span><span class="params">(VoteRequest voteRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果term &lt; currentTerm返回 false</span></span><br><span class="line">    <span class="comment">// 如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他</span></span><br><span class="line">&#125;</span><br><span class="line">Class VoteRequest &#123;</span><br><span class="line">    <span class="comment">/** 候选人的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** 候选人Id */</span></span><br><span class="line">    <span class="keyword">long</span> candidateId;</span><br><span class="line">    <span class="comment">/** 候选人的最后日志条目的索引值 */</span></span><br><span class="line">    <span class="keyword">long</span> lastLogIndex;</span><br><span class="line">    <span class="comment">/** 候选人最后日志条目的任期号 */</span></span><br><span class="line"><span class="keyword">long</span> lastLogTerm</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoteResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 当前节点的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** 是否投票 */</span></span><br><span class="line">    <span class="keyword">boolean</span> voteGranted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群刚启动的时候，所有节点都是Follower状态。如果Follower在选举超时内每收到心跳或者投票请求，它就会进行选举投票，先增加自己的任期号并转换为Candidate，然后向其他节点发送RPC投票请求。</p><ol><li>获得了大多数的选票。修改状态为Leader，修改维护的<code>nextIndex[]</code>数组为当前日志条目的索引，关闭等待超时计时器，开启心跳计时器并发送心跳包。</li><li>其他节点成为Leader。如果Leader的任期号不小于当前任期号，修改状态为Follower。</li><li>出现同票情况。<strong>随机生成超时时间</strong>后重新开始新一轮的选举。</li></ol><br><h4 id="追加条目（AppendEntries-）"><a href="#追加条目（AppendEntries-）" class="headerlink" title="追加条目（AppendEntries()）"></a>追加条目（AppendEntries()）</h4><p>只能由Leader -&gt; 其他节点，不能到Leader，是单向的。</p><p>Client发送RPC请求，Leader首先会将日志追加到本地，追加失败则返回false。然后通过AppendEntries()方法同步到其他节点上去，当Leader收到大多数节点响应true时，会将该日志条目Commit，然后将结果返回给Client，然后通知其他节点Commit。</p><p><img src="https://img-blog.csdnimg.cn/1c3ecc44b48e4c98ba95afb371da216d.png#pic_center"></p><p>当追加的条目为空时，代表这是个心跳包</p><ul><li>如果当前任期大于请求任期，返回false</li><li>如果当前日志条目没有能够与preLogIndex和preLogTerm匹配的，返回false</li><li>重置等待计时器等待时间</li><li>如果发生条目冲突（索引相同，任期不同），删除冲突索引以后的所有日志</li><li>追加日志条目</li><li>如果Leader的commitIndex大于本地的，将本地的设置为min(commitIndex. logIndex) </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendResponse <span class="title">appendEntries</span><span class="params">(AppendRequest appendRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前任期大于请求任期，返回false</span></span><br><span class="line">    <span class="comment">// 如果当前日志条目没有能够与preLogIndex和preLogTerm匹配的，返回false</span></span><br><span class="line">    <span class="comment">// 重置等待计时器等待时间</span></span><br><span class="line">    <span class="comment">// 如果发生条目冲突（索引相同，任期不同），删除冲突索引以后的所有日志</span></span><br><span class="line"><span class="comment">// 追加日志条目</span></span><br><span class="line">    <span class="comment">// 如果Leader的commitIndex大于本地的，将本地的设置为min(commitIndex. logIndex)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Leader的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** LeaderId */</span></span><br><span class="line">    <span class="keyword">long</span> leaderId;</span><br><span class="line">    <span class="comment">/** 新日志的前一个日志条目的索引 */</span></span><br><span class="line">    <span class="keyword">long</span> preLogIndex;</span><br><span class="line">    <span class="comment">/** 新日志的前一个日志条目的任期号 */</span></span><br><span class="line"><span class="keyword">long</span> preLogTerm;</span><br><span class="line">    <span class="comment">/** 需要添加的条目信息 */</span></span><br><span class="line">    List&lt;Entry&gt; entries;</span><br><span class="line">    <span class="comment">/** Leader的提交索引 */</span></span><br><span class="line"><span class="keyword">long</span> leaderCommit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** 命令 */</span></span><br><span class="line">    String command;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 当前节点的任期号 */</span></span><br><span class="line">    <span class="keyword">long</span> term;</span><br><span class="line">    <span class="comment">/** Follower的条目是否与Leader的匹配上了 */</span></span><br><span class="line">    <span class="keyword">boolean</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leader对于每个Follower都维护 一个<code>nextIndex</code>，记录需要给该Follower发送的下一个日志条目的索引。当某一个节点刚成为Leader时，它会将所有<code>nextIndex</code>设置为自己的最后一个日志的<code>index + 1</code>。如果一个Follower的日志和Leader不一致，那么在下一次的<code>AppendEntries()</code> RPC 时的一致性检查就会失败。在被Follower拒绝之后，Leader就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得Leader和Follower的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把Follower冲突的日志条目全部删除并且加上Leader的日志。一旦附加日志 RPC 成功，那么Follower的日志就会和Leader保持一致，并且在接下来的任期里一直继续保持。</p><br><br><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="核心类图"><a href="#核心类图" class="headerlink" title="核心类图"></a>核心类图</h3><p><img src="https://img-blog.csdnimg.cn/1b78a00d87e44195a208197bd16d63ce.png#pic_center"></p><br><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="requestVote"><a href="#requestVote" class="headerlink" title="requestVote()"></a>requestVote()</h4><ul><li>如果候选人的term &lt; currentTerm，不给该候选人投票</li><li>如果当前节点没有投票或者投给了候选人并且候选人日志和当前节点一样新，就给该候选人投票</li></ul><p><img src="https://img-blog.csdnimg.cn/bc6bc9a94adc44e9b7ededac6c8d4b43.png#pic_center"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点选举</span></span><br><span class="line"><span class="comment"> * 选举超时：Follower等待成为Leader的时间，随机设置在150ms ~ 300ms</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           &#123;</span></span><br><span class="line"><span class="comment"> *                              term:           候选人任期号</span></span><br><span class="line"><span class="comment"> *                              candidateId:    候选人Id</span></span><br><span class="line"><span class="comment"> *                              lastLogIndex:   候选人最好的日志条目索引值</span></span><br><span class="line"><span class="comment"> *                              lastLogTerm:    候选人最后日志条目的任期号</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> * ZRaftResponse            &#123;</span></span><br><span class="line"><span class="comment"> *                              &quot;term&quot;:         当前任期号</span></span><br><span class="line"><span class="comment"> *                              &quot;voteGranted&quot;:  true / false</span></span><br><span class="line"><span class="comment"> *                                              是否被投票</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestVote</span><span class="params">(VoteRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                        StreamObserver&lt;ZRaftResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当节点收到比自己大的任期，会将自己的任期设置为相同的，然后直接投票</span></span><br><span class="line">    <span class="comment">// 当节点收到和自己一样大的任期，会看自己是否已经投票来判断</span></span><br><span class="line">    ZRaftResponse response = ZRaftResponse.newBuilder()</span><br><span class="line">                                    .setTerm(NodeManager.node.getCurrentTerm())</span><br><span class="line">                                    .setSuccess(vote(request))</span><br><span class="line">                                    .build();</span><br><span class="line"></span><br><span class="line">    responseObserver.onNext(response);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前节点是否投票给候选人</span></span><br><span class="line"><span class="comment"> * 如果候选人的term &lt; currentTerm，不给该候选人投票</span></span><br><span class="line"><span class="comment"> * 如果当前节点没有投票或者投给了候选人并且候选人日志和当前节点一样新，就给该候选人投票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           候选人id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>                  true / false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">vote</span><span class="params">(VoteRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> term = request.getTerm();</span><br><span class="line">    <span class="keyword">long</span> currentTerm = NodeManager.node.getCurrentTerm();</span><br><span class="line">    <span class="keyword">if</span> (term &lt; currentTerm) &#123;</span><br><span class="line">        <span class="comment">// 如果请求者任期小于当前节点任期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (term &gt; currentTerm) &#123;</span><br><span class="line">        <span class="comment">// 更新等待定时器的时间</span></span><br><span class="line">        NodeManager.electionListener</span><br><span class="line">            .updatePreHeartTime(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// 修改节点任期信息</span></span><br><span class="line">        zRaftService.updateNodeTermInfo(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> votedFor = NodeManager.node.getVotedFor();</span><br><span class="line">    <span class="keyword">long</span> candidateId = request.getCandidateId();</span><br><span class="line">    <span class="keyword">if</span> (votedFor == <span class="number">0</span> ||</span><br><span class="line">        (votedFor == candidateId &amp;&amp;</span><br><span class="line">         NodeManager.node.getLogIndex() == request.getLastLogIndex() &amp;&amp;</span><br><span class="line">         NodeManager.node.getLastLogTerm() == request.getLastLogTerm())) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有投票或者</span></span><br><span class="line">        <span class="comment">// 给请求者投票了并且日志索引与任期能对应</span></span><br><span class="line">        <span class="comment">// 更新等待定时器的时间</span></span><br><span class="line">        NodeManager.electionListener</span><br><span class="line">            .updatePreHeartTime(System.currentTimeMillis());</span><br><span class="line">        NodeManager.node.setLeaderId(<span class="number">0</span>);</span><br><span class="line">        NodeManager.node.setVotedFor(candidateId);</span><br><span class="line">        NodeManager.printNodeInfo();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="appendEntries"><a href="#appendEntries" class="headerlink" title="appendEntries()"></a>appendEntries()</h4><ol><li>Leader接收到数据更改，将更改添加到节点日志中（不提交）</li><li>将该条目复制到Follower，等待回复，直到大多数（n / 2 + 1）节点响应成功。如果没有超过半数的节点响应成功，隔段超时时间后重新发送。</li><li>Leader提交数据，然后将结果返回给并通知Follower进行提交</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 追加条目，心跳，节点间数据的同步，日志复制</span></span><br><span class="line"><span class="comment"> * 1. Leader接收到数据更改，将更改添加到节点日志中（不提交）</span></span><br><span class="line"><span class="comment"> * 2. 将该条目复制到Follower，等待回复，直到大多数（n / 2 + 1）</span></span><br><span class="line"><span class="comment"> *    节点响应成功。如果没有超过半数的节点响应成功，隔段超时时间后重新发送</span></span><br><span class="line"><span class="comment"> * 3. Leader提交数据，然后将结果返回给并通知Follower进行提交</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           &#123;</span></span><br><span class="line"><span class="comment"> *                              term:           Leader任期</span></span><br><span class="line"><span class="comment"> *                              leaderId:       有时候可能是Candidate收到请求，</span></span><br><span class="line"><span class="comment"> *                                              需要将请求重定向到Leader去</span></span><br><span class="line"><span class="comment"> *                              preLogIndex:    前一个日志条目的索引</span></span><br><span class="line"><span class="comment"> *                              preLogTerm:     前一个日志条目的任期</span></span><br><span class="line"><span class="comment"> *                              entries:        需要被保存的日志条目（如果为空，代表是心跳）</span></span><br><span class="line"><span class="comment"> *                              leaderCommit:   Leader已提交的最高日志条目的索引</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> * ZRaftResponse            &#123;</span></span><br><span class="line"><span class="comment"> *                              &quot;term&quot;:         当前任期</span></span><br><span class="line"><span class="comment"> *                              &quot;success&quot;:      true / false。如果Candidate</span></span><br><span class="line"><span class="comment"> *                                              所含有的条目和prevLogIndex以及preLogTerm</span></span><br><span class="line"><span class="comment"> *                                              匹配上，则为true。</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendEntries</span><span class="params">(AppendRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                          StreamObserver&lt;ZRaftResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    NodeManager.printLog(<span class="string">&quot;appendEntries...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZRaftResponse.Builder builder = ZRaftResponse.newBuilder()</span><br><span class="line">            .setTerm(NodeManager.node.getCurrentTerm());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果currentTerm &gt; term</span></span><br><span class="line">    <span class="keyword">long</span> term = request.getTerm();</span><br><span class="line">    <span class="keyword">long</span> currentTerm = NodeManager.node.getCurrentTerm();</span><br><span class="line">    <span class="keyword">if</span> (term &lt; currentTerm) &#123;</span><br><span class="line">        <span class="comment">// 返回false</span></span><br><span class="line">        builder.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        responseObserver.onNext(builder.build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新等待计时器</span></span><br><span class="line">    NodeManager.electionListener</span><br><span class="line">            .updatePreHeartTime(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果term &gt; currentTerm 或者当前节点状态是Candidate</span></span><br><span class="line">    Node.NodeState state = NodeManager.node.getNodeState();</span><br><span class="line">    <span class="keyword">if</span> (term &gt; currentTerm || state == Node.NodeState.CANDIDATE) &#123;</span><br><span class="line">        <span class="comment">// 修改任期状态并切换为Follower</span></span><br><span class="line">        zRaftService.levelDown(request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置LeaderId</span></span><br><span class="line">        <span class="keyword">long</span> leaderId = NodeManager.node.getLeaderId();</span><br><span class="line">        <span class="keyword">if</span> (leaderId == <span class="number">0</span>) &#123;</span><br><span class="line">            NodeManager.node.setLeaderId(request.getLeaderId());</span><br><span class="line">            NodeManager.node.setNodeState(Node.NodeState.FOLLOWER);</span><br><span class="line">            NodeManager.printNodeInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> preLogTerm = request.getPreLogTerm();</span><br><span class="line">    <span class="keyword">long</span> preLogIndex = request.getPreLogIndex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果Leader日志索引不能在当前节点的索引上找到</span></span><br><span class="line">    <span class="keyword">if</span> (!NodeManager.node.entryIsExist(preLogTerm, preLogIndex)) &#123;</span><br><span class="line">        <span class="comment">// 返回false</span></span><br><span class="line">        builder.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        responseObserver.onNext(builder.build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是心跳包</span></span><br><span class="line">    List&lt;Entry&gt; entries = request.getEntriesList();</span><br><span class="line">    <span class="keyword">if</span> (entries.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 添加日志条目</span></span><br><span class="line">        b = NodeManager.node.addLogEntries(preLogIndex, entries);</span><br><span class="line">        NodeManager.printLog(NodeManager.node.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否要提交条目</span></span><br><span class="line">    <span class="keyword">long</span> leaderCommit = request.getLeaderCommit();</span><br><span class="line">    <span class="keyword">long</span> commitIndex = NodeManager.node.getCommitIndex();</span><br><span class="line">    <span class="keyword">if</span> (leaderCommit &gt; commitIndex) &#123;</span><br><span class="line">        <span class="comment">// 将提交</span></span><br><span class="line">        b = NodeManager.node.commitLog(leaderCommit) &amp;&amp; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builder.setSuccess(b);</span><br><span class="line">    responseObserver.onNext(builder.build());</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="sendCommand"><a href="#sendCommand" class="headerlink" title="sendCommand()"></a>sendCommand()</h4><p>客户端调用的RPC方法。</p><p>如果当前节点是Leader:</p><ul><li>第一阶段，将指令保存在log条目中，给其他节点发送AppendEntries，异步等待消息。</li><li>第二阶段，当大多数节点返回true，在本地进行提交并将结果返回给用户，同时向其他节点发送提交命令.</li></ul><p>如果当前节点是Follower:</p><ul><li>将该请求重定向到Leader去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用的RPC方法。</span></span><br><span class="line"><span class="comment"> * 如果当前节点是Leader:</span></span><br><span class="line"><span class="comment"> *    第一阶段，将指令保存在log条目中，给其他节点发送AppendEntries，异步等待消息。</span></span><br><span class="line"><span class="comment"> *    第二阶段，当大多数节点返回true，在本地进行提交并将结果返回给用户，同时向其他节点</span></span><br><span class="line"><span class="comment"> *    发送提交命令.</span></span><br><span class="line"><span class="comment"> * 如果当前节点是Follower:</span></span><br><span class="line"><span class="comment"> *    将该请求重定向到Leader去。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request           指令集（字符串list）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCommand</span><span class="params">(Command request, StreamObserver&lt;ClientResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    ProtocolStringList commandList = request.getCommandList();</span><br><span class="line">    ClientResponse.Builder builder = ClientResponse.newBuilder();</span><br><span class="line">    <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> size = commandList.size();</span><br><span class="line">    Node.NodeState state = NodeManager.node.getNodeState();</span><br><span class="line">    <span class="keyword">long</span> leaderId = NodeManager.node.getLeaderId();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> || state != Node.NodeState.LEADER) &#123;</span><br><span class="line">        <span class="comment">// 如果用户没有发送条目或者当前节点不是Leader，直接返回false并添加LeaderId</span></span><br><span class="line">        responseObserver.onNext(builder.setSuccess(b).setLeaderId(leaderId).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理该请求</span></span><br><span class="line">    <span class="comment">// 第一阶段，保存指令到本地并给其他节点发送消息</span></span><br><span class="line">    <span class="keyword">long</span> currentTerm = NodeManager.node.getCurrentTerm();</span><br><span class="line">    List&lt;Entry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String command : commandList) &#123;</span><br><span class="line">        Entry entry = Entry.newBuilder()</span><br><span class="line">                           .setTerm(currentTerm)</span><br><span class="line">                           .setCommand(command)</span><br><span class="line">                           .build();</span><br><span class="line">        entries.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!NodeManager.node.addLogEntries(entries)) &#123;</span><br><span class="line">        <span class="comment">// 如果本地添加条目失败，返回false</span></span><br><span class="line">        responseObserver.onNext(builder.setSuccess(b).setLeaderId(leaderId).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将返回交给AppendFutureListener</span></span><br><span class="line">    AppendFutureListener.responseObserver = responseObserver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送RPC请求</span></span><br><span class="line">    zRaftService.sendAppendEntries(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft论文</a></p><p><a href="http://thesecretlivesofdata.com/raft">Raft动态展示</a></p><p><a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT6.824</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;7月份的时候参加了一个阿里天池的性能优化比赛，后面在复赛的时候因为是集群场景，需要考虑各个节点之间数据的一致性，本来想自己实现的，但奈何时间太短（ps: 太菜了😭），最终还是找了市面上成熟的中间件来实现（Ignite）。这不，还是手痒，自己实现一个基于Raft的一致性服务。&lt;/p&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/zhaommmmomo/zraft&quot;&gt;zraft&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://zhaommmmomo.cn/&quot;&gt;zhaommmmomo&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="分布式" scheme="http://zhaommmmomo.cn/categories/Code/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="协议" scheme="http://zhaommmmomo.cn/categories/Code/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="实现" scheme="http://zhaommmmomo.cn/categories/Code/%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="算法" scheme="http://zhaommmmomo.cn/categories/Code/%E5%AE%9E%E7%8E%B0/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="http://zhaommmmomo.cn/tags/Java/"/>
    
    <category term="算法" scheme="http://zhaommmmomo.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="分布式" scheme="http://zhaommmmomo.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="一致性协议" scheme="http://zhaommmmomo.cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="实现" scheme="http://zhaommmmomo.cn/tags/%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Icarus主题的一些常用配置</title>
    <link href="http://zhaommmmomo.cn/2021/09/14/Icarus%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://zhaommmmomo.cn/2021/09/14/Icarus%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2021-09-14T09:11:14.000Z</published>
    <updated>2021-11-25T13:55:37.297Z</updated>
    
    <content type="html"><![CDATA[<p>常见的一些配置见<code>_config.icarus.yml</code>，英文不差都能看懂，或者去看<a href="https://ppoffice.github.io/hexo-theme-icarus">icarus文档</a>。本文主要就是一些网上很少的配置。</p><p>Icarus: 4.0.0</p><span id="more"></span><br><h3 id="文章页面两栏布局"><a href="#文章页面两栏布局" class="headerlink" title="文章页面两栏布局"></a>文章页面两栏布局</h3><p>在<code>_config.icarus.yml</code>目录下，创建<code>_config.post.yml</code>文件，该文件内容与<code>_config.icarus.yml</code>文件一样，用于单独加载post界面布局。注意，双栏需要将widgets内容的position都设置为同一边。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单独文章界面布局</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line">    <span class="comment"># 个人信息</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">profile</span></span><br><span class="line">        <span class="attr">author:</span> <span class="string">zhaommmmomo</span></span><br><span class="line">        <span class="attr">author_title:</span> <span class="string">fahaxiki!</span></span><br><span class="line">        <span class="attr">location:</span> <span class="string">Yantai,China</span></span><br><span class="line">        <span class="attr">avatar:</span> <span class="string">/img/logo.jpg</span></span><br><span class="line">        <span class="attr">avatar_rounded:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">follow_link:</span> <span class="string">&#x27;https://zhaommmmomo.cn&#x27;</span></span><br><span class="line">        <span class="attr">social_links:</span></span><br><span class="line">            <span class="attr">Github:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">&#x27;https://github.com/zhaommmmomo&#x27;</span></span><br><span class="line">    <span class="comment"># 文章目录</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">toc</span></span><br><span class="line">        <span class="comment"># 目录序号</span></span><br><span class="line">        <span class="attr">index:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 侧边栏是否固定</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">left:</span></span><br><span class="line">        <span class="attr">sticky:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">right:</span></span><br><span class="line">        <span class="attr">sticky:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><br><br><h3 id="增加两栏布局下文章的宽度"><a href="#增加两栏布局下文章的宽度" class="headerlink" title="增加两栏布局下文章的宽度"></a>增加两栏布局下文章的宽度</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># layout/layout.jsx</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">            &lt;Head site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; /&gt;</span><br><span class="line">        </span><br><span class="line">            # &lt;body <span class="class"><span class="keyword">class</span></span>=&#123;<span class="string">`is-<span class="subst">$&#123;columnCount&#125;</span>-column`</span>&#125;&gt;修改为下面一行</span><br><span class="line">            &lt;body <span class="class"><span class="keyword">class</span></span>=&#123;<span class="string">`is-3-column`</span>&#125;&gt;</span><br><span class="line">                ......</span><br><span class="line">                                # <span class="string">&#x27;is-8-tablet is-8-desktop is-8-widescreen&#x27;</span>: columnCount === <span class="number">2</span></span><br><span class="line">            # 修改为下面一行</span><br><span class="line">                                <span class="string">&#x27;is-8-tablet is-8-desktop is-9-widescreen&#x27;</span>: columnCount === <span class="number">2</span>,</span><br><span class="line">                                <span class="string">&#x27;is-8-tablet is-8-desktop is-6-widescreen&#x27;</span>: columnCount === <span class="number">3</span></span><br><span class="line">                            &#125;)&#125; dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: body &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># layout/common/widgets.jsx</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColumnSizeClass</span>(<span class="params">columnCount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (columnCount) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            # <span class="keyword">return</span> <span class="string">&#x27;is-4-tablet is-4-desktop is-4-widescreen&#x27;</span>;# 修改为下面一行</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;is-4-tablet is-4-desktop is-3-widescreen&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;is-4-tablet is-4-desktop is-3-widescreen&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># include/style/responsive<span class="selector-class">.styl</span></span><br><span class="line">+widescreen()</span><br><span class="line"># 增加</span><br><span class="line">    <span class="selector-class">.is-3-column</span> <span class="selector-class">.container</span></span><br><span class="line">        <span class="attribute">max-width</span>: $widescreen - $gap</span><br><span class="line">        width: $widescreen - $gap</span><br><span class="line"></span><br><span class="line">+<span class="built_in">fullhd</span>()</span><br><span class="line"># 增加</span><br><span class="line">    .is-<span class="number">3</span>-column .container</span><br><span class="line">        max-width: $fullhd - <span class="number">2</span> * $gap</span><br><span class="line">        width: $fullhd - <span class="number">2</span> * $gap</span><br></pre></td></tr></table></figure><br><br><h3 id="开启文章目录"><a href="#开启文章目录" class="headerlink" title="开启文章目录"></a>开启文章目录</h3><ol><li>在<code>_config.yml</code>中添加<code>toc: true</code></li><li>在<code>_config.icarus.yml</code>或者<code>_config.post.yml</code>中添加</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">widgets:</span></span><br><span class="line">    <span class="comment"># 文章目录</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">toc</span></span><br><span class="line">        <span class="comment"># 目录序号</span></span><br><span class="line">        <span class="attr">index:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br><br><h3 id="只固定目录"><a href="#只固定目录" class="headerlink" title="只固定目录"></a>只固定目录</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># source/js/main.js</span><br><span class="line"><span class="keyword">const</span> $toc = $(<span class="string">&#x27;#toc&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ($toc.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    $toc.addClass(<span class="string">&#x27;column-left is-sticky&#x27;</span>);# 添加</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># include/style/widget<span class="selector-class">.styl</span> 添加下面</span><br><span class="line"><span class="selector-id">#toc</span></span><br><span class="line">    <span class="attribute">max-height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">22px</span>)</span><br><span class="line">    overflow-y: scroll</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的一些配置见&lt;code&gt;_config.icarus.yml&lt;/code&gt;，英文不差都能看懂，或者去看&lt;a href=&quot;https://ppoffice.github.io/hexo-theme-icarus&quot;&gt;icarus文档&lt;/a&gt;。本文主要就是一些网上很少的配置。&lt;/p&gt;
&lt;p&gt;Icarus: 4.0.0&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="其他" scheme="http://zhaommmmomo.cn/categories/Code/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Hexo" scheme="http://zhaommmmomo.cn/tags/Hexo/"/>
    
    <category term="icarus" scheme="http://zhaommmmomo.cn/tags/icarus/"/>
    
    <category term="配置" scheme="http://zhaommmmomo.cn/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList底层逻辑与实现</title>
    <link href="http://zhaommmmomo.cn/2021/09/11/ArrayList%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhaommmmomo.cn/2021/09/11/ArrayList%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-11T08:12:26.000Z</published>
    <updated>2021-11-25T13:55:37.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>扩容规则：</strong>底层是System.arraycopy()这个方法</p><ol><li>每次扩容都是将新容量设置为1.5 * 旧容量</li><li>新容量如果小于需要的容量，将新容量设置为需要的容量</li><li>新容量如果大于可以分配的最大容量（整型最大值 - 8），新容量设置为（需要的容量小于最大分配容量）需要的容量或者设置为（需要的容量大于最大分配容量）整型最大值</li></ol><br><p><strong>懒加载机制：</strong>ArrayList初始化的时候并没有直接给数组分配容量，而是使用的一个空数组进行赋值，只有当第一次增加的时候才会真正的给数组进行容量分配。这样是为了防止用户初始化后没有进行使用导致内存的浪费。（只有用户调用无参构造方法的时候才是懒加载，其他两个构造函数是分配的另外一个空数组）</p><span id="more"></span><br><br><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来表示当用户输入初始容量为0时的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来表示是懒加载的数组，与EMPTY_ELEMENTDATA做区分</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存储元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来记录已经存储了的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><br><br><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>我们可以看到我们经常用的<code>List&lt;Integer&gt; arr = new ArrayList&lt;&gt;()</code>，并没有一开始给我们初始化为默认的10容量，而是先赋值的是一个空数组。这里其实就是懒加载的开始，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用的是懒加载的空数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用的是非懒加载的空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 使用的是非懒加载的空数组</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用来确定是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现懒加载的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前数组是否是懒加载的数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 如果是的话返回max(默认初始容量，需要的容量)</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是直接返回需要的容量</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录操作数量</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要的容量小于数组容量，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容函数</span></span><br><span class="line"><span class="comment"> * 每次在原来基础上一半一半的扩容。</span></span><br><span class="line"><span class="comment"> * 如果新容量还是小于需要的容量，将新容量设为需要的容量</span></span><br><span class="line"><span class="comment"> * 如果新容量大于最大分配的容量：</span></span><br><span class="line"><span class="comment"> *      1. 需要的容量也大于。将新容量设置为整型的最大值</span></span><br><span class="line"><span class="comment"> *      2. 需要的容量小于，将新容量直接设置为需要的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 在老容量的基础上增加一半</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里就是判断需要的容量是否大于可分配容量</span></span><br><span class="line">        <span class="comment">// 如果大于就将新容量设置为整型的最大值</span></span><br><span class="line">        <span class="comment">// 如果小于就将新容量设置为需要的容量</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zmm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/11/11 15:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空的数组集合，用于懒加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENT_DATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来记录已经存放了的数据个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这里是给数组赋值的空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENT_DATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrList</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里直接就给数组进行了初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initCapacity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initCapacity == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENT_DATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initCapacity];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个新元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e             新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        lazyLoad();</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; elementData.length) &#123;</span><br><span class="line">            grow();</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定下标处添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index         下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lazyLoad();</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; elementData.length) &#123;</span><br><span class="line">            grow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将原数组下标在index及以后的所有元素复制到以index + 1开始的下标处</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData,</span><br><span class="line">                 index + <span class="number">1</span>, size - index - <span class="number">1</span>);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定下标处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index         下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>              指定下标处的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改指定下标处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index         下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element       新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒加载机制</span></span><br><span class="line"><span class="comment">     * 当调用第一次添加的时候才对数组进行初始化操作</span></span><br><span class="line"><span class="comment">     * 如果当类加载后直接进行初始化，而用户未使用</span></span><br><span class="line"><span class="comment">     * 这样就会导致额外的内存浪费</span></span><br><span class="line"><span class="comment">     * 所以这就是为什么刚初始化ArrayList，显示的容量为0</span></span><br><span class="line"><span class="comment">     * 添加后就变成了10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容函数</span></span><br><span class="line"><span class="comment">     * 每次在原来基础上一半一半的扩容。</span></span><br><span class="line"><span class="comment">     * 如果新容量还是小于需要的容量，将新容量设为需要的容量</span></span><br><span class="line"><span class="comment">     * 如果新容量大于最大分配的容量：</span></span><br><span class="line"><span class="comment">     *      1. 需要的容量也大于。将新容量设置为整型的最大值</span></span><br><span class="line"><span class="comment">     *      2. 需要的容量小于，将新容量直接设置为需要的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldSize = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newSize = oldSize + (oldSize &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newSize - size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newSize = size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; MAX_ARRAY_SIZE)&#123;</span><br><span class="line">            newSize = size &gt; MAX_ARRAY_SIZE ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;重点&quot;&gt;&lt;a href=&quot;#重点&quot; class=&quot;headerlink&quot; title=&quot;重点&quot;&gt;&lt;/a&gt;重点&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;扩容规则：&lt;/strong&gt;底层是System.arraycopy()这个方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次扩容都是将新容量设置为1.5 * 旧容量&lt;/li&gt;
&lt;li&gt;新容量如果小于需要的容量，将新容量设置为需要的容量&lt;/li&gt;
&lt;li&gt;新容量如果大于可以分配的最大容量（整型最大值 - 8），新容量设置为（需要的容量小于最大分配容量）需要的容量或者设置为（需要的容量大于最大分配容量）整型最大值&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;p&gt;&lt;strong&gt;懒加载机制：&lt;/strong&gt;ArrayList初始化的时候并没有直接给数组分配容量，而是使用的一个空数组进行赋值，只有当第一次增加的时候才会真正的给数组进行容量分配。这样是为了防止用户初始化后没有进行使用导致内存的浪费。（只有用户调用无参构造方法的时候才是懒加载，其他两个构造函数是分配的另外一个空数组）&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="Java" scheme="http://zhaommmmomo.cn/categories/Code/Java/"/>
    
    <category term="Collection" scheme="http://zhaommmmomo.cn/categories/Code/Java/Collection/"/>
    
    
    <category term="Java" scheme="http://zhaommmmomo.cn/tags/Java/"/>
    
    <category term="源码" scheme="http://zhaommmmomo.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Collection" scheme="http://zhaommmmomo.cn/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Thread</title>
    <link href="http://zhaommmmomo.cn/2021/08/01/Java%E4%B8%AD%E7%9A%84Thread/"/>
    <id>http://zhaommmmomo.cn/2021/08/01/Java%E4%B8%AD%E7%9A%84Thread/</id>
    <published>2021-08-01T02:25:22.000Z</published>
    <updated>2021-11-25T13:55:37.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想必各位都对线程这个词不陌生，我们都知道Java中可以通过Thread、Rannable、Callable和线程池来创建一个线程。但是一个线程的创建、运行到结束到底是一个什么样的过程呢？我们以一段代码为入口点来看看Java到底是如何弄的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run...&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><br><br><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"><span class="comment">// 优先级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>            priority;</span><br><span class="line"><span class="comment">// 没有用到。可能在虚拟机调用的时候会有用。</span></span><br><span class="line"><span class="keyword">private</span> Thread         threadQ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>           eetop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否单步执行此线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     single_step;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是守护线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     stillborn = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run方法实现</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程的线程组</span></span><br><span class="line"><span class="keyword">private</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个线程的上下文类加载器</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line"><span class="comment">// 线程继承的上下文</span></span><br><span class="line"><span class="keyword">private</span> AccessControlContext inheritedAccessControlContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于编号线程名，单调递增</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与当前线程相关的ThreadLocal值</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程继承的ThreadLocal值</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的栈大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> stackSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在本机线程终止后持续存在的 JVM 私有状态。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nativeParkEventPointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程Id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> tid;</span><br><span class="line"><span class="comment">// 用于生成线程Id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> threadSeqNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有用到。可能在虚拟机调用的时候会有用。</span></span><br><span class="line"><span class="keyword">volatile</span> Object parkBlocker;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"><span class="comment">// 中断时锁住的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="开始到结束"><a href="#开始到结束" class="headerlink" title="开始到结束"></a>开始到结束</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 方便调用本地方法块</span></span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h4><p>主要就是初始化线程的一些基本信息（线程名、栈大小、线程组、父线程、优先级、上下文信息等）和安全检测。</p><p><strong>注意</strong>：这里并没有将线程添加到线程组里面，只是增加线程组中未启动线程的计数。<code>addUnstarted()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// param1: 线程组</span></span><br><span class="line">    <span class="comment">// param2: Runnable</span></span><br><span class="line">    <span class="comment">// param3: 线程名（从0开始递增）</span></span><br><span class="line">    <span class="comment">// param4: 分配的栈大小（初始为0）</span></span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从0开始递增</span></span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程的初始化方法</span></span><br><span class="line"><span class="comment"> * 主要就是初始化线程的一些基本信息（线程名、栈大小、线程组、父线程、优先级等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g                     线程组，一般为null，除非有传入。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target                Runnable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name                  线程名。从0开始，单调递增</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize             新线程所需的堆栈大小，或为零表示将忽略此参数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc上下文信息。如果为null，就获取当前线程的上下文信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals   是否从构造线程继承可继承线程局部的初始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前正在执行的线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">// 安全验证</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 就算线程组为null也会设置为父线程的线程组</span></span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全检查</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加线程组中未启动线程的计数。未启动的线程不会添加到线程组中，</span></span><br><span class="line">    <span class="comment">// 以便在它们从未启动时可以收集它们，但必须对其进行计数，</span></span><br><span class="line">    <span class="comment">// 以便其中包含未启动线程的守护线程组不会被销毁。</span></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 会根据父线程是否是守护线程来设置该线程是否为守护线程</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="comment">// 根据父线程的优先级来设置该线程的优先级</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="comment">// 是否采用当前上下文信息</span></span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="comment">// 设置优先级</span></span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 栈大小</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    <span class="comment">// 设置线程Id。从0开始单调递增</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><p>首先会判断该线程状态是否是<code>NEW</code>，是的话就将该线程添加到线程组里面（因为在<code>init()</code>方法里面只是增加了计数，并未添加到线程组里面），然后调用Native方法<code>start0()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0 对应 NEW</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将线程添加到线程组中</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用native方法。这个方法会修改线程的状态为Running</span></span><br><span class="line">        start0();</span><br><span class="line">        <span class="comment">// 在start0()方法执行完成之后，代表线程已经要开始运行了</span></span><br><span class="line">        <span class="comment">// 会直接执行run()方法，而主线程可能还在执行started = true</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                <span class="comment">// 开启失败</span></span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h4><p>被系统方法调用。将该线程从线程组中删除，如果线程组是守护线程组并且没有活动线程并且没有未启动的线程并且没有子线程组，就将该线程组进行销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出方法。是被系统调用的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将该线程从线程组中删除</span></span><br><span class="line">        <span class="comment">// 如果该线程组是守护线程组并且活动线程数为0</span></span><br><span class="line">        <span class="comment">// 并且未启动的线程为0并且没有子线程组，销毁该线程组</span></span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadTerminated</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 将指定线程从线程组中删除。就是从线程数组里面删除该线程</span></span><br><span class="line">        remove(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程组中活动线程数为0，唤醒所有线程</span></span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是守护线程组并且活动线程数为0并且未启动的线程为0并且没有子线程</span></span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 销毁该线程组</span></span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3 id="Thread状态"><a href="#Thread状态" class="headerlink" title="Thread状态"></a>Thread状态</h3><p>Thread状态的变化都是通过一些native方法进行改变的。</p><h4 id="getState"><a href="#getState" class="headerlink" title="getState()"></a>getState()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们可以看到这里调用的是虚拟机里面的方法</span></span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class: sun.misc.VM;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过&amp;运算符来计算线程的状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">toThreadState</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((var0 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.RUNNABLE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">1024</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.BLOCKED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">32</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TIMED_WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TERMINATED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (var0 &amp; <span class="number">1</span>) == <span class="number">0</span> ? State.NEW : State.RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;想必各位都对线程这个词不陌生，我们都知道Java中可以通过Thread、Rannable、Callable和线程池来创建一个线程。但是一个线程的创建、运行到结束到底是一个什么样的过程呢？我们以一段代码为入口点来看看Java到底是如何弄的线程。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;run...&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="Java" scheme="http://zhaommmmomo.cn/categories/Code/Java/"/>
    
    <category term="Thread" scheme="http://zhaommmmomo.cn/categories/Code/Java/Thread/"/>
    
    
    <category term="Java" scheme="http://zhaommmmomo.cn/tags/Java/"/>
    
    <category term="源码" scheme="http://zhaommmmomo.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="线程" scheme="http://zhaommmmomo.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux中TCP三次握手的实现</title>
    <link href="http://zhaommmmomo.cn/2021/07/11/Linux%E4%B8%ADTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhaommmmomo.cn/2021/07/11/Linux%E4%B8%ADTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-11T00:41:04.000Z</published>
    <updated>2021-11-25T13:55:37.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上三次握手八股文一大堆，我“为了面试”也去看了看，刚好那时候接触Linux比较多，突然想到<code>TCP三次握手在Linux内核中是如何去实现的呢</code>？是不是会有不同？然后我就开始了漫长的百度（ps: 我比较菜，还不能拿着Linux上千个源码文件去怼）、源码之路。终于弄清了Linux中TCP三次握手的大致过程。</p><span id="more"></span><br><br><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我那边都知道TCP建立连接前都需要客户端发送一个SYN包，服务端响应一个SYN + ACK包，客户端响应一个ACK包，这是三次握手的基本流程。</p><p><img src="https://img-blog.csdnimg.cn/d6665e364dc54466a16871c5613e2311.png#pic_center"></p><p>但如果让我们去实现三次握手，应该怎么去设计呢？</p><br><br><h2 id="Linux中的实现"><a href="#Linux中的实现" class="headerlink" title="Linux中的实现"></a>Linux中的实现</h2><p>我们以网络编程中的相应函数为切入点</p><p>Linux中三次握手的主要函数有socket()、bind()、listen()、connect()、recv()、accept()</p><p><img src="https://img-blog.csdnimg.cn/8323f56c928a41728d7cec206c821c6b.png#pic_center"></p><br><h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><p>socket 在内核里并不是一个内核对象。而是包含 file、socket、sock 等多个相关内核对象构成，每个内核对象还定义了 ops 操作函数集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的是一个文件描述符fd</span></span><br><span class="line">fd = socket(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><br><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>调用bind()函数绑定端口，会使connect()时选择端口方式无效。不推荐在客户端中使用bind()，这会打乱connect的端口选择过程。（但某些情况下可能会bind()，比如说在服务端和客户端进行协商使用什么端口来调用）</p><p><strong>流程：</strong></p><ol><li><p>判断用户传入的端口是否小于1024</p></li><li><p>调用inet_csk_get_port来判断传入端口是否被占用，如果被占用就返回EADDRINUSE。这个方法不会到 ESTABLISH 的哈希表进行可用检测，只在 bind 状态的 socket 里查。所以<strong>默认情况下，只要端口用过一次就不会再次使用</strong>。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/af_inet.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_bind</span><span class="params">(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =</span> (struct sockaddr_in *)uaddr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> snum;</span><br><span class="line"><span class="keyword">int</span> chk_addr_ret;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;</span><br><span class="line">        <span class="comment">// 如果这个socket有他自己的bind()函数，就使用这个bind()函数</span></span><br><span class="line">err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户传入的端口号</span></span><br><span class="line">snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">err = -EACCES;</span><br><span class="line"><span class="comment">// 传入的端口号不允许小于1024</span></span><br><span class="line"><span class="keyword">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp; !capable(CAP_NET_BIND_SERVICE))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 尝试确定端口号</span></span><br><span class="line">    <span class="comment">// 实际调用的是inet_csk_get_port，用来尝试确定端口号是否被占用</span></span><br><span class="line">    <span class="comment">// 如果被占用就返回EADDRINUSE，然后就会显示&quot;Address already in use&quot;(端口被占用)</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">err = -EADDRINUSE;</span><br><span class="line"><span class="keyword">goto</span> out_release_sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/inet_connection_sock.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *获取对给定sock的本地端口的引用，</span></span><br><span class="line"><span class="comment"> *  如果snum为零，则表示选择任何可用的本地端口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_get_port</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">short</span> snum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span> =</span> sk-&gt;sk_prot-&gt;h.hashinfo;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> *<span class="title">tb</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret, attempts = <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line"><span class="keyword">int</span> smallest_size = <span class="number">-1</span>, smallest_rover;</span><br><span class="line"></span><br><span class="line">local_bh_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果传入的snum不为0</span></span><br><span class="line"><span class="keyword">if</span> (!snum) &#123;</span><br><span class="line"><span class="keyword">int</span> remaining, rover, low, high;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="comment">// 获取本地指定的端口范围</span></span><br><span class="line">inet_get_local_port_range(&amp;low, &amp;high);</span><br><span class="line">remaining = (high - low) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在端口范围中取一个随机位置开始遍历</span></span><br><span class="line">smallest_rover = rover = net_random() % remaining + low;</span><br><span class="line"></span><br><span class="line">smallest_size = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果本地设置了一个端口不可用</span></span><br><span class="line"><span class="keyword">if</span> (inet_is_reserved_local_port(rover))</span><br><span class="line"><span class="keyword">goto</span> next_nolock;</span><br><span class="line">            </span><br><span class="line">head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, rover,</span><br><span class="line">hashinfo-&gt;bhash_size)];</span><br><span class="line">spin_lock(&amp;head-&gt;lock);</span><br><span class="line">inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 冲突检测，如果端口是用到的，去have_sum逻辑</span></span><br><span class="line"><span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == rover) &#123;</span><br><span class="line"><span class="keyword">if</span> (tb-&gt;fastreuse &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    sk-&gt;sk_reuse &amp;&amp;</span><br><span class="line">    sk-&gt;sk_state != TCP_LISTEN &amp;&amp;</span><br><span class="line">    (tb-&gt;num_owners &lt; smallest_size || smallest_size == <span class="number">-1</span>)) &#123;</span><br><span class="line">smallest_size = tb-&gt;num_owners;</span><br><span class="line">smallest_rover = rover;</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;hashinfo-&gt;bsockets) &gt; (high - low) + <span class="number">1</span>) &#123;</span><br><span class="line">spin_unlock(&amp;head-&gt;lock);</span><br><span class="line">snum = smallest_rover;</span><br><span class="line"><span class="keyword">goto</span> have_snum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">next:</span><br><span class="line">spin_unlock(&amp;head-&gt;lock);</span><br><span class="line">next_nolock:</span><br><span class="line"><span class="keyword">if</span> (++rover &gt; high)</span><br><span class="line">rover = low;</span><br><span class="line">&#125; <span class="keyword">while</span> (--remaining &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exhausted local port range during search?  It is not</span></span><br><span class="line"><span class="comment"> * possible for us to be holding one of the bind hash</span></span><br><span class="line"><span class="comment"> * locks if this test triggers, because if &#x27;remaining&#x27;</span></span><br><span class="line"><span class="comment"> * drops to zero, we broke out of the do/while loop at</span></span><br><span class="line"><span class="comment"> * the top level, not from the &#x27;break;&#x27; statement.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (smallest_size != <span class="number">-1</span>) &#123;</span><br><span class="line">snum = smallest_rover;</span><br><span class="line"><span class="keyword">goto</span> have_snum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* OK, here is the one we will use.  HEAD is</span></span><br><span class="line"><span class="comment"> * non-NULL and we hold it&#x27;s mutex.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">snum = rover;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">have_snum:</span><br><span class="line">head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, snum,</span><br><span class="line">hashinfo-&gt;bhash_size)];</span><br><span class="line">spin_lock(&amp;head-&gt;lock);</span><br><span class="line">inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)</span><br><span class="line"><span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == snum)</span><br><span class="line">                <span class="comment">// 判断端口是否被占用</span></span><br><span class="line"><span class="keyword">goto</span> tb_found;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h3><p><strong>主要是申请和初始化接收队列，包括全连接队列和半连接队列</strong></p><p><strong>全连接队列长度：</strong>用户传入的 backlog 和 net.core.somaxconn 之间较小的那个值</p><p><strong>半连接队列长度：</strong>min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再上取整到 2 的幂次，但最小不能小于16。</p><p><strong>流程：</strong></p><ol><li>根据文件描述符fd查找socket内核对象</li><li>获取内核参数net.core.somaxconn，与用户传入的backlog相比较，取最小的</li><li>调用sock-&gt;ops-&gt;listen(sock, backlog)函数，实际是inet_listen</li><li>判断是否是listen状态<ul><li>如果不是listen状态，<strong>开始监听（接收队列的创建、初始化。内存申请、半连接队列长度的计算、全连接队列头的初始化等）</strong>。1. 计算半连接队列长度（<strong>与sysctl_max_syn_backlog取 一次最小值；保证不能比8小；向上对齐到2的整数次幂</strong>）。2. 申请内存。3. 全队列头初始化，设置为null。4. 将半连接队列挂载到接收队列上。</li></ul></li><li>设置<strong>全连接队列的长度（backlog与net.core.somaxconn之间较小的哪个值）</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/socket.c</span></span><br><span class="line">SYSCALL_DEFINE2(listen, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, backlog)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, fput_needed;</span><br><span class="line"><span class="keyword">int</span> somaxconn;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 fd（文件描述符） 查找对应的 socket 内核对象</span></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (sock) &#123;</span><br><span class="line"><span class="comment">// 获取内核参数</span></span><br><span class="line">somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line"><span class="comment">// 如果设置的backlog大于核心参数</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span>)backlog &gt; somaxconn)</span><br><span class="line"><span class="comment">// 使用核心参数</span></span><br><span class="line">backlog = somaxconn;</span><br><span class="line"></span><br><span class="line">err = security_socket_listen(sock, backlog);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="comment">// 调用协议栈注册的listen函数</span></span><br><span class="line">err = sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line"></span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="comment">// 服务端的全连接队列长度是listen时传入的backlog和net.core.somaxconn之间最小的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_listen</span><span class="params">(struct socket *sock, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 还不是listen状态（没有listen过）</span></span><br><span class="line"><span class="keyword">if</span> (old_state != TCP_LISTEN) &#123;</span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line">err = inet_csk_listen_start(sk, backlog);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置全连接队列长度</span></span><br><span class="line">sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/inet_connection_sock.c</span></span><br><span class="line"><span class="comment">// 用来初始化接收队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_listen_start</span><span class="params">(struct sock *sk, <span class="keyword">const</span> <span class="keyword">int</span> nr_table_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来申请和初始化icsk_accept_queue（半连接队列和全连接队列）这个对象</span></span><br><span class="line">    <span class="comment">// 1.定义接收队列数据结构</span></span><br><span class="line"><span class="comment">// 2.接收队列的申请和初始化（内存的申请、半连接队列长度的计算、全连接队列头的初始化）</span></span><br><span class="line">    <span class="keyword">int</span> rc = reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue, nr_table_entries);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/core/request_sock.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * queue：用来存放全连接和半连接队列的结构体</span></span><br><span class="line"><span class="comment"> * nr_table_entries：是内核参数和用户传入的backlog中的最小值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 定义一个listen_sock指针（半连接队列）</span></span><br><span class="line"><span class="comment"> * 2. 计算半连接队列的长度，然后申请内存。半连接队列的长度是 min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再上取整到 2 的幂次，但最小不能小于16。 </span></span><br><span class="line"><span class="comment"> * 3. 将全连接队列头queue-&gt;rskq_accept_head设置成NULL，</span></span><br><span class="line"><span class="comment"> *   将半连接队列挂载到接收队列queue上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reqsk_queue_alloc</span><span class="params">(struct request_sock_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_table_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> lopt_size = <span class="keyword">sizeof</span>(struct listen_sock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 半连接队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listen_sock</span> *<span class="title">lopt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算半连接队列的长度</span></span><br><span class="line"><span class="comment">// 再次和sysctl_max_syn_backlog内核对象又取一次最小值</span></span><br><span class="line">nr_table_entries = <span class="keyword">min_t</span>(u32, nr_table_entries, sysctl_max_syn_backlog);</span><br><span class="line"><span class="comment">// 保证nr_table_entries不能比8小。</span></span><br><span class="line">nr_table_entries = <span class="keyword">max_t</span>(u32, nr_table_entries, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 用来上对齐到2的整数次幂</span></span><br><span class="line"><span class="comment">// 比如说当前nr_table_entries是最小值8</span></span><br><span class="line"><span class="comment">// 经过roundup_pow_of_two（8+1） = 16</span></span><br><span class="line">nr_table_entries = roundup_pow_of_two(nr_table_entries + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为listen_sock对象申请内存，这里包含了半连接队列</span></span><br><span class="line">lopt_size += nr_table_entries * <span class="keyword">sizeof</span>(struct request_sock *);</span><br><span class="line"><span class="keyword">if</span> (lopt_size &gt; PAGE_SIZE)</span><br><span class="line">lopt = vzalloc(lopt_size);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">lopt = kzalloc(lopt_size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (lopt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了效率，不记录nr_table_entries</span></span><br><span class="line"><span class="comment">// 而是记录2的几次幂等于nr_table_entries</span></span><br><span class="line">    <span class="comment">// t</span></span><br><span class="line"><span class="keyword">for</span> (lopt-&gt;max_qlen_log = <span class="number">3</span>;</span><br><span class="line">     (<span class="number">1</span> &lt;&lt; lopt-&gt;max_qlen_log) &lt; nr_table_entries;</span><br><span class="line">     lopt-&gt;max_qlen_log++);</span><br><span class="line"></span><br><span class="line">get_random_bytes(&amp;lopt-&gt;hash_rnd, <span class="keyword">sizeof</span>(lopt-&gt;hash_rnd));</span><br><span class="line">rwlock_init(&amp;<span class="built_in">queue</span>-&gt;syn_wait_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全连接队列头初始化</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;rskq_accept_head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 半连接队列设置</span></span><br><span class="line">lopt-&gt;nr_table_entries = nr_table_entries;</span><br><span class="line">write_lock_bh(&amp;<span class="built_in">queue</span>-&gt;syn_wait_lock);</span><br><span class="line"><span class="built_in">queue</span>-&gt;listen_opt = lopt;</span><br><span class="line">write_unlock_bh(&amp;<span class="built_in">queue</span>-&gt;syn_wait_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p><strong>流程：</strong></p><ol><li>进入内核系统根据用户传入的fd（文件描述符）来查询对应的socket内核对象</li><li>调用该sock对象的sock-&gt;ops-&gt;connect方法（inet_stream_connect）</li><li>根据sock的状态来进入不同的处理逻辑。第一次connect，sock的状态都是unconnect，所以会调sk-&gt;sk_prot-&gt;connect方法（tcp_v4_connect）</li><li>将socket状态设置为TCP-SYN-SENT</li><li>动态选择一个端口（首先判断<strong>是否bind()了一个端口</strong>，如果没有，就根据目标地址和端口等信息生成一个随机数，然后在本地端口范围中通过这个随机数逐渐增加遍历，如果是本地配置的保留端口就跳过，如果不是就遍历已经使用的端口的<strong>哈希链表（hinfo-&gt;bhash）</strong>，判断是否已经被使用。如果<strong>该端口已经被使用并且<code>TCP连接中的四元组与当前建立的四元组完全一致</code>，就不可使用</strong>。继续遍历，找到了就返回端口，没找到就提示”Address already in use”）</li><li>进行tcp连接。（首先申请并设置skb，然后添加到发送队列sk_write_queue上，进行发送，启动重传定时器）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/socket.c</span></span><br><span class="line">SYSCALL_DEFINE3(connect, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,</span><br><span class="line"><span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户fd查找内核中的socket对象</span></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sock中ops的connect()方法</span></span><br><span class="line">    <span class="comment">// 其实是inet_stream_connect()</span></span><br><span class="line">err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,</span><br><span class="line"> sock-&gt;file-&gt;f_flags);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: ipv4/af_inet.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_stream_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">case</span> SS_CONNECTED:</span><br><span class="line">err = -EISCONN;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">case</span> SS_CONNECTING:</span><br><span class="line">err = -EALREADY;</span><br><span class="line"><span class="comment">/* Fall out of switch with err, set for this state */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line"><span class="comment">// 刚创建完的socket状态就是SS_UNCONNECTED，</span></span><br><span class="line">    <span class="comment">// 所以第一次connect的就会走这个case</span></span><br><span class="line">err = -EISCONN;</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sock的tcp_v4_connect方法</span></span><br><span class="line">err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改sock的状态</span></span><br><span class="line">sock-&gt;state = SS_CONNECTING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Just entered SS_CONNECTING state; the only</span></span><br><span class="line"><span class="comment"> * difference is that return value in non-blocking</span></span><br><span class="line"><span class="comment"> * case is EINPROGRESS, rather than EALREADY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = -EINPROGRESS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 启动传出连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_connect</span><span class="params">(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 设置socket状态为TCP_SYN_SENT</span></span><br><span class="line">tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态选择一个端口</span></span><br><span class="line">err = inet_hash_connect(&amp;tcp_death_row, sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用来根据sk中的信息，构建一个完成的syn报文，并将它发送出去</span></span><br><span class="line">err = tcp_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file:net/ipv4/inet_hashtables.c</span></span><br><span class="line"><span class="comment">// 绑定一个端口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_hash_connect</span><span class="params">(struct inet_timewait_death_row *death_row,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// inet_sk_port_offset(sk): 根据要连接的目的IP和端口等信息生成一个随机数</span></span><br><span class="line"><span class="comment">// __inet_check_established: 检查是否和现有 ESTABLISH 的连接是否冲突的时候用的函数</span></span><br><span class="line"><span class="keyword">return</span> __inet_hash_connect(death_row, sk, inet_sk_port_offset(sk),</span><br><span class="line">__inet_check_established, __inet_hash_nolisten);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file:net/ipv4/inet_hashtables.c</span></span><br><span class="line"><span class="comment">// 端口号选择</span></span><br><span class="line"><span class="keyword">int</span> __inet_hash_connect(struct inet_timewait_death_row *death_row,</span><br><span class="line">struct sock *sk, u32 port_offset,</span><br><span class="line"><span class="keyword">int</span> (*check_established)(struct inet_timewait_death_row *,</span><br><span class="line">struct sock *, __u16, struct inet_timewait_sock **),</span><br><span class="line"><span class="keyword">int</span> (*hash)(struct sock *sk, struct inet_timewait_sock *twp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hinfo</span> =</span> death_row-&gt;hashinfo;</span><br><span class="line"><span class="comment">// 是否绑定过端口（bind()方法）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> snum = inet_sk(sk)-&gt;inet_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> *<span class="title">tb</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line"><span class="keyword">int</span> twrefcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有绑定端口</span></span><br><span class="line"><span class="keyword">if</span> (!snum) &#123;</span><br><span class="line"><span class="keyword">int</span> i, remaining, low, high, port;</span><br><span class="line"><span class="keyword">static</span> u32 hint;</span><br><span class="line">u32 offset = hint + port_offset;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_timewait_sock</span> *<span class="title">tw</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本机的端口范围信息</span></span><br><span class="line">inet_get_local_port_range(&amp;low, &amp;high);</span><br><span class="line">remaining = (high - low) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">local_bh_disable();</span><br><span class="line"><span class="comment">// 遍历查找端口</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= remaining; i++) &#123;</span><br><span class="line">            <span class="comment">// 之前算出的随机数+i</span></span><br><span class="line">port = low + (i + offset) % remaining;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果本机配置了该端口不可用</span></span><br><span class="line"><span class="keyword">if</span> (inet_is_reserved_local_port(port))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找和遍历已经使用的端口的哈希链表</span></span><br><span class="line">head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port,</span><br><span class="line">hinfo-&gt;bhash_size)];</span><br><span class="line">spin_lock(&amp;head-&gt;lock);</span><br><span class="line"></span><br><span class="line">inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) &#123;</span><br><span class="line"><span class="comment">// 如果该端口已经被使用</span></span><br><span class="line"><span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp;</span><br><span class="line">    tb-&gt;port == port) &#123;</span><br><span class="line"><span class="keyword">if</span> (tb-&gt;fastreuse &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> next_port;</span><br><span class="line">WARN_ON(hlist_empty(&amp;tb-&gt;owners));</span><br><span class="line"><span class="comment">// 通过 check_established 继续检查是否可用</span></span><br><span class="line"><span class="keyword">if</span> (!check_established(death_row, sk,</span><br><span class="line">port, &amp;tw))</span><br><span class="line"><span class="keyword">goto</span> ok;</span><br><span class="line"><span class="keyword">goto</span> next_port;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file:net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="comment">// tcp连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_connect</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcp连接初始化</span></span><br><span class="line">tcp_connect_init(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请skb并构造为一个SYN包</span></span><br><span class="line">buff = alloc_skb_fclone(MAX_TCP_HEADER + <span class="number">15</span>, sk-&gt;sk_allocation);</span><br><span class="line"><span class="keyword">if</span> (unlikely(buff == <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> -ENOBUFS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到发送队列</span></span><br><span class="line">__tcp_add_write_queue_tail(sk, buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际发出syn</span></span><br><span class="line">err = tcp_transmit_skb(sk, buff, <span class="number">1</span>, sk-&gt;sk_allocation);</span><br><span class="line"><span class="keyword">if</span> (err == -ECONNREFUSED)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timer for repeating the SYN until an answer. */</span></span><br><span class="line"><span class="comment">// 启动重传定时器</span></span><br><span class="line">inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,</span><br><span class="line">  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断四元组</strong></p><p>两对四元组中只要任意一个元素不同，都算是两条不同的连接。以下的两条 TCP 连接完全可以同时存在（假设 192.168.1.101 是客户端，192.168.1.100 是服务端）</p><ul><li>连接1：192.168.0.1 5000 192.168.0.2 8090</li><li>连接2：192.168.0.1 5000 192.168.0.2 8091</li></ul><p>check_established 作用就是检测现有的 TCP 连接中是否四元组和要建立的连接四元素完全一致。如果不完全一致，那么该端口仍然可用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __inet_check_established(struct inet_timewait_death_row *death_row,</span><br><span class="line">    struct sock *sk, __u16 lport,</span><br><span class="line">    struct inet_timewait_sock **twp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到hash桶，所有ESTABLISH状态的socket组成的哈希表。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hash = inet_ehashfn(net, daddr, lport,</span><br><span class="line"> saddr, inet-&gt;inet_dport);</span><br><span class="line"></span><br><span class="line">spin_lock(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check TIME-WAIT sockets first. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历查看是否有四元组一样的，一样就报错</span></span><br><span class="line">sk_nulls_for_each(sk2, node, &amp;head-&gt;twchain) &#123;</span><br><span class="line">tw = inet_twsk(sk2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (INET_TW_MATCH(sk2, net, hash, acookie,</span><br><span class="line">saddr, daddr, ports, dif)) &#123;</span><br><span class="line"><span class="keyword">if</span> (twsk_unique(sk, sk2, twp))</span><br><span class="line"><span class="keyword">goto</span> unique;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">goto</span> not_unique;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    tw = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* And established part... */</span></span><br><span class="line">    <span class="comment">// 使用 INET_MATCH 来判断是否可用。</span></span><br><span class="line">sk_nulls_for_each(sk2, node, &amp;head-&gt;chain) &#123;</span><br><span class="line"><span class="keyword">if</span> (INET_MATCH(sk2, net, hash, acookie,</span><br><span class="line">saddr, daddr, ports, dif))</span><br><span class="line"><span class="keyword">goto</span> not_unique;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique:</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">not_unique:</span><br><span class="line">spin_unlock(lock);</span><br><span class="line"><span class="keyword">return</span> -EADDRNOTAVAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/inet_hashtables.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_MATCH(__sk, __net, __hash, __cookie, __saddr, __daddr, __ports, __dif)\</span></span><br><span class="line"><span class="meta">(((__sk)-&gt;sk_hash == (__hash)) &amp;&amp; net_eq(sock_net(__sk), (__net))&amp;&amp;\</span></span><br><span class="line"><span class="meta"> (inet_sk(__sk)-&gt;inet_daddr== (__saddr))&amp;&amp;\</span></span><br><span class="line"><span class="meta"> (inet_sk(__sk)-&gt;inet_rcv_saddr== (__daddr))&amp;&amp;\</span></span><br><span class="line"><span class="meta"> ((*((__portpair *)&amp;(inet_sk(__sk)-&gt;inet_dport))) == (__ports))&amp;&amp;\</span></span><br><span class="line"><span class="meta"> (!((__sk)-&gt;sk_bound_dev_if) || ((__sk)-&gt;sk_bound_dev_if == (__dif))))</span></span><br></pre></td></tr></table></figure><p><strong>所以一台客户端机最大能建立的连接数并不是 65535。只要 server 足够多，单机发出百万条连接没有任何问题。</strong></p><br><h3 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h3><h4 id="服务器响应SYN"><a href="#服务器响应SYN" class="headerlink" title="服务器响应SYN"></a>服务器响应SYN</h4><p>主要工作是判断下接收队列是否满了，满的话可能会丢弃该请求，否则发出 synack。申请 request_sock 添加到半连接队列中，同时启动定时器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 处理握手过程 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_do_rcv</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经建立的TCP连接</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state == TCP_ESTABLISHED) &#123; <span class="comment">/* Fast path */</span></span><br><span class="line">sock_rps_save_rxhash(sk, skb-&gt;rxhash);</span><br><span class="line"><span class="keyword">if</span> (tcp_rcv_established(sk, skb, tcp_hdr(skb), skb-&gt;len)) &#123;</span><br><span class="line">rsk = sk;</span><br><span class="line"><span class="keyword">goto</span> reset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;len &lt; tcp_hdrlen(skb) || tcp_checksum_complete(skb))</span><br><span class="line"><span class="keyword">goto</span> csum_err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器收到第一步握手SYN或者第三步ACK都会进入里</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line"><span class="comment">// 进入tcp_v4_hnd_req中查看半连接队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nsk</span> =</span> tcp_v4_hnd_req(sk, skb);</span><br><span class="line"><span class="keyword">if</span> (!nsk)</span><br><span class="line"><span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nsk != sk) &#123;</span><br><span class="line">sock_rps_save_rxhash(nsk, skb-&gt;rxhash);</span><br><span class="line"><span class="keyword">if</span> (tcp_child_process(sk, nsk, skb)) &#123;</span><br><span class="line">rsk = nsk;</span><br><span class="line"><span class="keyword">goto</span> reset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">sock_rps_save_rxhash(sk, skb-&gt;rxhash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的socket状态进行不同的处理</span></span><br><span class="line"><span class="keyword">if</span> (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb-&gt;len)) &#123;</span><br><span class="line">rsk = sk;</span><br><span class="line"><span class="keyword">goto</span> reset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="comment">// 除了 ESTABLISHED 和 TIME_WAIT，其他状态下的 TCP 处理都走这里</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次握手或第三次握手，服务器收到ack包</span></span><br><span class="line"><span class="keyword">case</span> TCP_LISTEN:</span><br><span class="line"><span class="keyword">if</span> (th-&gt;ack)</span><br><span class="line"><span class="comment">// 如果是响应包</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (th-&gt;rst)</span><br><span class="line"><span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line"><span class="comment">// 如果是SYN握手包</span></span><br><span class="line"><span class="comment">// conn_request是个函数指针，指向tcp_v4_conn_request</span></span><br><span class="line"><span class="comment">// 服务器响应 SYN 的主要处理逻辑都在这个tcp_v4_conn_request里</span></span><br><span class="line"><span class="keyword">if</span> (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 响应SYN的主要处理逻辑都在这个方法中</span></span><br><span class="line"><span class="comment">// 1.先判断一下半连接队列是否满了</span></span><br><span class="line"><span class="comment">// 如果满了就进入tcp_syn_flood_action（syn flood攻击）查看是否开启tcp_syncookies内核参数，没有开启就会丢弃该握手包</span></span><br><span class="line"><span class="comment">// 2.判断全连接队列是否满了</span></span><br><span class="line"><span class="comment">// 如果满了并且如果有young_ack，直接丢弃</span></span><br><span class="line"><span class="comment">// young_ack（未处理完的半连接请求）是半连接队列里保持着的一个计数器。</span></span><br><span class="line"><span class="comment">// 记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK,</span></span><br><span class="line"><span class="comment">// 同时也没有完成过三次握手的sock数量</span></span><br><span class="line"><span class="comment">// 3.申请request_sock分配内核对象</span></span><br><span class="line"><span class="comment">// 4.构造syn+ack包并发送响应，tcp_v4_send_synack()方法中。</span></span><br><span class="line"><span class="comment">// 5.添加到半连接队列中并开启计时器重传。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_conn_request</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断半连接队列是否满了，如果满了就进入syn_flood_warning去判断是否开启</span></span><br><span class="line"><span class="comment">// 了 tcp_syncookies 内核参数。</span></span><br><span class="line"><span class="comment">// 如果队列满，且未开启 tcp_syncookies，那么该握手包将直接被丢弃</span></span><br><span class="line"><span class="keyword">if</span> (inet_csk_reqsk_queue_is_full(sk) &amp;&amp; !isn) </span><br><span class="line"><span class="keyword">if</span> (net_ratelimit())</span><br><span class="line">syn_flood_warning(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在全连接的情况下，如果有young_ack，那么直接丢</span></span><br><span class="line"><span class="comment">// young_ack 是半连接队列里保持着的一个计数器。</span></span><br><span class="line"><span class="comment">// 记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK,</span></span><br><span class="line"><span class="comment">// 同时也没有完成过三次握手的sock数量</span></span><br><span class="line"><span class="keyword">if</span> (sk_acceptq_is_full(sk) &amp;&amp; inet_csk_reqsk_queue_young(sk) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配request_sock内核对象</span></span><br><span class="line">req = inet_reqsk_alloc(&amp;tcp_request_sock_ops);</span><br><span class="line"><span class="keyword">if</span> (!req)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp_v4_send_synack()构造并发送syn+ack响应</span></span><br><span class="line"><span class="keyword">if</span> (tcp_v4_send_synack(sk, dst, req,</span><br><span class="line">       (struct request_values *)&amp;tmp_ext) ||</span><br><span class="line">    want_cookie)</span><br><span class="line"><span class="keyword">goto</span> drop_and_free;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到半连接队列，并开启计时器</span></span><br><span class="line"><span class="comment">// 计时器的作用是在某个时间之内还收不到客户端的第三次握手，</span></span><br><span class="line"><span class="comment">// 服务器就会重传syn+ack包</span></span><br><span class="line">inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/tcp_ipv4.c   </span></span><br><span class="line"><span class="comment">// 构造并发送syn + ack</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_v4_send_synack</span><span class="params">(struct sock *sk, struct dst_entry *dst,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct request_values *rvp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造syn + ack包</span></span><br><span class="line">skb = tcp_make_synack(sk, dst, req, rvp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb) &#123;</span><br><span class="line">        <span class="comment">// 如果构建成功</span></span><br><span class="line">__tcp_v4_send_check(skb, ireq-&gt;loc_addr, ireq-&gt;rmt_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送syn + ack响应</span></span><br><span class="line">err = ip_build_and_send_pkt(skb, sk, ireq-&gt;loc_addr,</span><br><span class="line">    ireq-&gt;rmt_addr,</span><br><span class="line">    ireq-&gt;opt);</span><br><span class="line">err = net_xmit_eval(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst_release(dst);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="客户端响应SYN-ACK"><a href="#客户端响应SYN-ACK" class="headerlink" title="客户端响应SYN + ACK"></a>客户端响应SYN + ACK</h4><p>清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，开启保活计时器后发出第三次握手的 ack 确认。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 客户端第二次握手处理</span></span><br><span class="line"><span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line"><span class="comment">// 处理 syn+ack 包</span></span><br><span class="line">queued = tcp_rcv_synsent_state_process(sk, skb, th, len);</span><br><span class="line"><span class="keyword">if</span> (queued &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> queued;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do step6 onward by hand. */</span></span><br><span class="line">tcp_urg(sk, skb, th);</span><br><span class="line">__kfree_skb(skb);</span><br><span class="line">tcp_data_snd_check(sk);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_rcv_synsent_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (th-&gt;ack) &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改socket状态</span></span><br><span class="line">tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立完成</span></span><br><span class="line">security_inet_conn_established(sk, skb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化拥塞控制</span></span><br><span class="line">tcp_init_congestion_control(sk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保活计时器打开</span></span><br><span class="line"><span class="keyword">if</span> (sock_flag(sk, SOCK_KEEPOPEN))</span><br><span class="line">inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_write_pending ||</span><br><span class="line">    icsk-&gt;icsk_accept_queue.rskq_defer_accept ||</span><br><span class="line">    icsk-&gt;icsk_ack.pingpong) &#123;</span><br><span class="line"><span class="comment">/* Save one ACK. Data will be ready after</span></span><br><span class="line"><span class="comment"> * several ticks, if write_pending is set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It may be deleted, but with this feature tcpdumps</span></span><br><span class="line"><span class="comment"> * look so _wonderfully_ clever, that I was not able</span></span><br><span class="line"><span class="comment"> * to stand against the temptation 8)     --ANK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟确认</span></span><br><span class="line">inet_csk_schedule_ack(sk);</span><br><span class="line">icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span><br><span class="line">icsk-&gt;icsk_ack.ato = TCP_ATO_MIN;</span><br><span class="line">tcp_incr_quickack(sk);</span><br><span class="line">tcp_enter_quickack_mode(sk);</span><br><span class="line">inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,</span><br><span class="line">  TCP_DELACK_MAX, TCP_RTO_MAX);</span><br><span class="line"></span><br><span class="line">discard:</span><br><span class="line">__kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 申请构造ack包然后返回响应</span></span><br><span class="line">tcp_send_ack(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* No ACK in the segment */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (th-&gt;rst) &#123;</span><br><span class="line"><span class="comment">/* rfc793:</span></span><br><span class="line"><span class="comment"> * &quot;If the RST bit is set</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Otherwise (no ACK) drop the segment and return.&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> discard_and_undo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line"><span class="comment">/* We see SYN without ACK. It is attempt of</span></span><br><span class="line"><span class="comment"> * simultaneous connect with crossed SYNs.</span></span><br><span class="line"><span class="comment"> * Particularly, it can be connect to self.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是syn包，就设置socket状态为TCP_SYN_RECV</span></span><br><span class="line">tcp_set_state(sk, TCP_SYN_RECV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序号seq+1</span></span><br><span class="line">tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line">tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送syn + ack包</span></span><br><span class="line">        tcp_send_synack(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_send_ack</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 申请和构造ack包</span></span><br><span class="line">buff = alloc_skb(MAX_TCP_HEADER, GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 发送ack包</span></span><br><span class="line">tcp_transmit_skb(sk, buff, <span class="number">0</span>, GFP_ATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="服务端响应ACK"><a href="#服务端响应ACK" class="headerlink" title="服务端响应ACK"></a>服务端响应ACK</h4><p>把当前半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端第三次握手的ack与第一次握手一样，都会进入到tcp_v4_do_rcv，此时去半连接队列中查看就不是空的了，会保留第一次握手的半连接信息</span></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct sock *<span class="title">tcp_v4_hnd_req</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 查找listen socket的半连接队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span> =</span> inet_csk_search_req(sk, &amp;prev, th-&gt;source,</span><br><span class="line">       iph-&gt;saddr, iph-&gt;daddr);</span><br><span class="line"><span class="keyword">if</span> (req)</span><br><span class="line">        <span class="comment">// 如果找到了</span></span><br><span class="line"><span class="keyword">return</span> tcp_check_req(sk, skb, req, prev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file：net/ipv4/tcp_minisocks.c</span></span><br><span class="line"><span class="comment">// 主要是创建一个子socket，然后清理半连接队列，添加到全连接队列中</span></span><br><span class="line"><span class="function">struct sock *<span class="title">tcp_check_req</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct request_sock **prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建子socket</span></span><br><span class="line"><span class="comment">// 对应的是tcp_v4_syn_recv_sock 函数</span></span><br><span class="line">child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (child == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> listen_overflow;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理半连接队列</span></span><br><span class="line">inet_csk_reqsk_queue_unlink(sk, req, prev);</span><br><span class="line">inet_csk_reqsk_queue_removed(sk, req);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加全连接队列</span></span><br><span class="line">inet_csk_reqsk_queue_add(sk, req, child);</span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 创建sock内核对象</span></span><br><span class="line"><span class="function">struct sock *<span class="title">tcp_v4_syn_recv_sock</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct dst_entry *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断接收队列是否满了，如果满了就修改一下计数器然后丢弃</span></span><br><span class="line"><span class="keyword">if</span> (sk_acceptq_is_full(sk))</span><br><span class="line"><span class="keyword">goto</span> exit_overflow;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建sock &amp;&amp; 初始化</span></span><br><span class="line">newsk = tcp_create_openreq_child(sk, req, skb);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: include/net/inet_connection_sock.h </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inet_csk_reqsk_queue_unlink</span><span class="params">(struct sock *sk,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct request_sock **prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 把连接请求块从半连接队列中删除</span></span><br><span class="line">reqsk_queue_unlink(&amp;inet_csk(sk)-&gt;icsk_accept_queue, req, prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/syncookies.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inet_csk_reqsk_queue_add</span><span class="params">(struct sock *sk,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct sock *child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将握手成功的request_sock对象插入到全连接队列链表的尾部</span></span><br><span class="line">reqsk_queue_add(&amp;inet_csk(sk)-&gt;icsk_accept_queue, req, sk, child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line"><span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line"><span class="comment">//第三次握手处理</span></span><br><span class="line"><span class="keyword">if</span> (acceptable) &#123;</span><br><span class="line">tp-&gt;copied_seq = tp-&gt;rcv_nxt;</span><br><span class="line">smp_mb();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改状态为已连接</span></span><br><span class="line">tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h3><p><strong>服务端accept：</strong>从已建立好的全连接队列中取第一个返回给用户进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/inet_connection_sock.c</span></span><br><span class="line"><span class="function">struct sock *<span class="title">inet_csk_accept</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> *err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从全连接队列中获取第一个元素</span></span><br><span class="line">newsk = reqsk_queue_get_child(&amp;icsk-&gt;icsk_accept_queue, sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:include/net/request_sock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct sock *<span class="title">reqsk_queue_get_child</span><span class="params">(struct request_sock_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct sock *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 从全连接队列中获取第一个元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span> =</span> reqsk_queue_remove(<span class="built_in">queue</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">child</span> =</span> req-&gt;sk;</span><br><span class="line"></span><br><span class="line">WARN_ON(child == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">sk_acceptq_removed(parent);</span><br><span class="line">__reqsk_free(req);</span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:include/net/request_sock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">reqsk_queue_removed</span><span class="params">(struct request_sock_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct request_sock *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listen_sock</span> *<span class="title">lopt</span> =</span> <span class="built_in">queue</span>-&gt;listen_opt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;retrans == <span class="number">0</span>)</span><br><span class="line">--lopt-&gt;qlen_young;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> --lopt-&gt;qlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>握手前的准备</strong></p><ul><li>客户端：通过<code>socket()</code>方法获取一个fd文件描述符，通过bind()方法绑定一个端口（可以不调用该方法；如果调用了，首先会判断用户 传入的端口号是否大于1024，然后通过<code>inet_csk_get_port</code>方法判断该端口是否被占用，如果被占用就返回``EADDRINUSE`。只会在bind状态的socket里面查找，不会去ESTABLISH 的哈希表进行可用检测）</li><li>服务端：通过<code>socket()</code>方法获取一个fd文件描述符，通过listen()方法初始化连接队列（全连接队列大小 = <code>min(backlog, net.core.somaxconn)</code>，半连接队列大小 = <code>min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再向上取整到 2 的幂次，但最小不能小于16</code>）</li></ul><p><strong>第一次握手</strong></p><ul><li>客户端：根据传入的fd文件描述符，找到对应的socket内核对象。调用<code>sock-&gt;ops-&gt;connect</code>方法（<code>inet_stream_connect</code>），然后在<code>tcp_v4_connect()</code>方法中将socket状态设置为<code>TCP_SYN_SENT</code>，通过<code>_inet_hash_connect()</code>方法动态选择一个端口号（首先判断是否<code>bind()</code>了一个端口，如果没有，就<strong>根据目标地址和端口等信息生成一个随机数</strong>，然后在本地端口范围中通过这个随机数逐渐增加遍历，如果是本地配置的保留端口就跳过，如果不是就遍历已经使用的端口的哈希链表（<code>hinfo-&gt;bhash</code>），判断是否已经被使用，如果该端口已经被使用并且<strong>TCP连接中的四元组与当前建立的四元组完全一致</strong>，就不能使用，继续遍历。找到了就返回端口，没找到就提示<code>Address already in use</code>）。通过<code>tcp_connect()</code>构建skb并添加到发送队列<code>sk_write_queue</code>上，启动重传定时器，进行发送。</li></ul><p><strong>第二次握手</strong></p><ul><li>服务端：首先会判断半连接队列是否满了，如果满了就进入<code>syn_flood_warning</code>去判断是否开启了 <code>tcp_syncookies</code> 内核参数。如果队列满，且未开启 <code>tcp_syncookies</code>，那么该握手包将直接被丢弃，然后去判断一下全连接队列是否满了，如果满了并且有<code>young_ack</code>，直接丢弃，否则发出 synack。申请<code>request_sock</code> 添加到半连接队列中，同时启动定时器。<code>young_ack</code>（未处理完的半连接请求）是半连接队列里保持着的一个计数器。记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK,同时也没有完成过三次握手的sock数量。</li><li>客户端：清除重传定时器，将当前socket状态设置为ESTABLISHED，开启保活计时器后发出ack确认</li></ul><p><strong>第三次握手</strong></p><ul><li>服务端：找到半连接队列中的request_sock对象，判断全连接队列是否满了，如果满了就修改计数器然后丢弃，没满就创建新的sock对象，将半连接中的连接请求进行删除，添加到全连接队列中，将状态设置为<code>TCP_ESTABLISHED</code>。</li></ul><p><strong>最后</strong></p><p>调用<code>accept()</code>方法从全连接队列中获取一个返回给用户进程</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;网上三次握手八股文一大堆，我“为了面试”也去看了看，刚好那时候接触Linux比较多，突然想到&lt;code&gt;TCP三次握手在Linux内核中是如何去实现的呢&lt;/code&gt;？是不是会有不同？然后我就开始了漫长的百度（ps: 我比较菜，还不能拿着Linux上千个源码文件去怼）、源码之路。终于弄清了Linux中TCP三次握手的大致过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="Linux" scheme="http://zhaommmmomo.cn/categories/Code/Linux/"/>
    
    <category term="网络" scheme="http://zhaommmmomo.cn/categories/Code/Linux/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="源码" scheme="http://zhaommmmomo.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Linux" scheme="http://zhaommmmomo.cn/tags/Linux/"/>
    
    <category term="TCP" scheme="http://zhaommmmomo.cn/tags/TCP/"/>
    
    <category term="Linux网络" scheme="http://zhaommmmomo.cn/tags/Linux%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC大致过程</title>
    <link href="http://zhaommmmomo.cn/2021/04/26/SpringMVC%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/"/>
    <id>http://zhaommmmomo.cn/2021/04/26/SpringMVC%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/</id>
    <published>2021-04-26T07:54:03.000Z</published>
    <updated>2021-11-25T13:55:37.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是一种框架模式，将M和V的实现代码分离。</p><ol><li>M（Model）：模型，业务规则。处理请求、返回数据，数据可以被多个视图使用。</li><li>V（View）：视图，就是你能看到并能交互的界面。</li><li>C（Controller）：控制器，负责接收用户的请求去调用哪个M去处理，然后再返回确定哪个V显示数据。</li></ol><br><br><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>为什么在这里讲一下Servlet？其实SpringMVC就是一个Servlet，所以弄清楚Servlet的过程，SpringMVC的就类似了。</p><p>我们现来看一下Servlet的类图关系。</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20210426154402993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><br><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="SpringMVC和Servlet的关系"><a href="#SpringMVC和Servlet的关系" class="headerlink" title="SpringMVC和Servlet的关系"></a>SpringMVC和Servlet的关系</h3><p><img src="https://img-blog.csdnimg.cn/20210426154418637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><h3 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h3><ol><li>初始化的时候用了一个Map保存URL和Controller类的对应关系</li><li>根据请求的URL找到对应的Controller，然后从Controller中找到处理请求的方法</li><li>将请求参数绑定到方法的形参上，执行方法处理请求，并返回结果视图</li></ol><blockquote><p><img src="https://img-blog.csdnimg.cn/20210426154451427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><br><h3 id="九大组件"><a href="#九大组件" class="headerlink" title="九大组件"></a>九大组件</h3><p>在DispathcherServlet类中，我们可以找到SpringMVC的九大组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一</span></span><br><span class="line"><span class="comment"> *      用于处理上传请求。将普通请求封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> MultipartResolver multipartResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一：本地语言解析器</span></span><br><span class="line"><span class="comment"> *      从请求中解析出Local。主要用于i18n。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一：模板解析器</span></span><br><span class="line"><span class="comment"> *     负责从请求中解析出主题名，主题就是样式、图片以及它们所形成的显示效果的集合。相关类：</span></span><br><span class="line"><span class="comment"> * ThemeSource：根据主题名查找具体的主题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ThemeResolver themeResolver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一</span></span><br><span class="line"><span class="comment"> *     用来查找Handler。可以是类也可以是方法。</span></span><br><span class="line"><span class="comment"> *     比如标注了<span class="doctag">@RequestMapping</span>的每个方法都可以看成一个Handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一：适配器</span></span><br><span class="line"><span class="comment"> *     因为Servlet的方法结构都是doService(HttpServletRequest req,</span></span><br><span class="line"><span class="comment"> *                              HttpServletResponse resp)形式的，</span></span><br><span class="line"><span class="comment"> *  将SpringMVC中的Handler转为这种格式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一：异常处理器</span></span><br><span class="line"><span class="comment"> *    处理Handler产生的异常情况的组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一</span></span><br><span class="line"><span class="comment"> *    从请求中获取ViewName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RequestToViewNameTranslator viewNameTranslator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一</span></span><br><span class="line"><span class="comment"> *    用于管理FlashMap。FlashMap用于重定向时的参数传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> FlashMapManager flashMapManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        九大组件之一：视图解析器</span></span><br><span class="line"><span class="comment"> * 将String类型的视图名和Locale解析为View类型的视图，只有一个resolveViewName()方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br></pre></td></tr></table></figure><br><br><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="SpringMVC初始化"><a href="#SpringMVC初始化" class="headerlink" title="SpringMVC初始化"></a>SpringMVC初始化</h3><p>首先我们从Servlet的初始化init()开始，在DispatcherServlet类中，我们并没有发现Servlet的初始化方法，所以我们去父类中去找找。在HttpServletBean中我们终于发现了init()方法。</p><p><img src="https://img-blog.csdnimg.cn/2021042615452244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们可以看见这里只是对一些初始的属性参数进行了设置，具体通过子类调用initServletBean()这个方法来调用。我们点进去看看</p><p><img src="https://img-blog.csdnimg.cn/20210426154533201.png#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/20210426154542734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们可以看到子类FrameworkServlet的initServletBean()方法中添加了一些日志相关的信息，以及一个重要的方法**initWebApplicationContext()**，这个方法最终会调用我们IoC容器的refresh()方法。剩下的initFrameworkServlet()这个方法是个空方法，可以留给我们进行扩展。我们继续跟进initWebApplicationContext()方法。<br><img src="https://img-blog.csdnimg.cn/20210426154555282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们进入createWebApplicationContext()方法中</p><p><img src="https://img-blog.csdnimg.cn/20210426154610819.png#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/20210426154620337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>configureAndRefreshWebApplicationContext()方法，终于我们看见了refresh()方法</p><p><img src="https://img-blog.csdnimg.cn/20210426154636971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>其实就是IoC容器的初始化。</p><p>我们接着看SpringMVC九大组件的初始化</p><p>在DispatcherServlet中，onRefresh()方法和initStrategies()方法</p><p><img src="https://img-blog.csdnimg.cn/20210426155251360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p>到此，SpringMVC初始化差不多就完成了，下面去看看SpringMVC是如何处理请求的。</p><br><br><h3 id="SpringMVC处理请求"><a href="#SpringMVC处理请求" class="headerlink" title="SpringMVC处理请求"></a>SpringMVC处理请求</h3><p>在doService()方法中。其中最核心的方法是doDispatch()方法。<br><img src="https://img-blog.csdnimg.cn/20210426154652663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们进入doDispatch()。</p><p>这里面的处理大致流程是：</p><ol><li>先判断一下是不是文件上传</li><li>通过getHandler()方法找到请求对应的处理handler的Bean实例以及添加一些拦截器，封装成一个HandlerExecutionChain请求处理链对象</li><li>获取一个支持的处理适配器HandlerAdapter。getHandlerAdapter()</li><li>调用给定的handler处理请求，执行并返回结果视图。handle()</li><li>处理一下处理的结果，可以是ModelAndView或者是一个异常。processDispatchResult()</li></ol><p><img src="https://img-blog.csdnimg.cn/20210426154703565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们先去看看getHandler()方法。</p><p><img src="https://img-blog.csdnimg.cn/20210426154713168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>继续点进去，在AbstractHandlerMapping的getHandler()方法中。</p><p><img src="https://img-blog.csdnimg.cn/20210426154722181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>是不是看见了一个我们很熟悉的方法？getBean()。这时候我们就获取到了对应handler的实例了，然后就是调用getHandlerExecutionChain()方法，将一些拦截器与之封装为一个HandlerExecutionChain。</p><p><img src="https://img-blog.csdnimg.cn/20210426154732881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>这时候一个HandlerExecutionChain就完成了。</p><p>然后我们去看看getHandlerAdapter()方法。</p><p><img src="https://img-blog.csdnimg.cn/2021042615474283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>接下来是handle()方法，我们点进去看看，他会调用AbstractHandlerMethodAdapter类的handle方法，我们会发现它最后会调用handleInternal()这个方法，交给子类去实现。</p><p><img src="https://img-blog.csdnimg.cn/20210426154752356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>进入handleInternal()方法</p><p><img src="https://img-blog.csdnimg.cn/20210426154801463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们可以看见都会调用invokeHandlerMethod()这个方法，跟进去。都是些什么addXXX、setXXX、registerXXX方法。最重要的是invokeAndHandle()方法，它完成了将请求中的参数和方法中的参数进行绑定，通过@RequestParam注解或者是ASM框架。</p><p><img src="https://img-blog.csdnimg.cn/20210426154812326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>invokeAndHandle()方法</p><p><img src="https://img-blog.csdnimg.cn/20210426154821588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>然后就是返回相应的ModelAndView了。</p><p>接下来对ModelAndView进行处理，在processDispatchResult()方法中。可以看见对异常的处理和对正常视图的处理。</p><p><img src="https://img-blog.csdnimg.cn/20210426154831199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>其中调用了render()方法对视图进行渲染。</p><p><img src="https://img-blog.csdnimg.cn/20210426154839886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p>到此，一个请求的处理差不多就完成了。SpringMVC的工作也差不多结束了。其中还有些细节的地方，比如在将请求中的参数和方法的参数绑定时ASM框架的使用，感兴趣可以去看看。</p><br><br><h3 id="关于调用了refresh-方法，九大组件什么时候初始化。"><a href="#关于调用了refresh-方法，九大组件什么时候初始化。" class="headerlink" title="关于调用了refresh()方法，九大组件什么时候初始化。"></a>关于调用了refresh()方法，九大组件什么时候初始化。</h3><p><img src="https://img-blog.csdnimg.cn/20210427215143112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p>前面我们知道看初始化的时候，如果进行了refresh()，下面的onRefresh()方法好像就不能调用了啊，那九大组件到底是什么时候初始化的呢？</p><p>这其实用到了<strong>事件监听器</strong>。我们都知道IoC容器的refresh()方法中有事件传播器的注册（initApplicationEventMulticaster()方法）、事件的发布（finishRefresh()）方法。其实就是在事件发布的时候，调用了SpringMVC九大组件的初始化。我们后续再讲。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h2&gt;&lt;p&gt;MVC是一种框架模式，将M和V的实现代码分离。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;M（Model）：模型，业务规则。处理请求、返回数据，数据可以被多个视图使用。&lt;/li&gt;
&lt;li&gt;V（View）：视图，就是你能看到并能交互的界面。&lt;/li&gt;
&lt;li&gt;C（Controller）：控制器，负责接收用户的请求去调用哪个M去处理，然后再返回确定哪个V显示数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;br&gt;

&lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h2&gt;&lt;p&gt;为什么在这里讲一下Servlet？其实SpringMVC就是一个Servlet，所以弄清楚Servlet的过程，SpringMVC的就类似了。&lt;/p&gt;
&lt;p&gt;我们现来看一下Servlet的类图关系。&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/categories/Code/Spring/"/>
    
    
    <category term="源码" scheme="http://zhaommmmomo.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Bean的生命周期</title>
    <link href="http://zhaommmmomo.cn/2021/04/24/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://zhaommmmomo.cn/2021/04/24/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-04-24T03:41:47.000Z</published>
    <updated>2021-11-25T13:55:37.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean是什么？"><a href="#Bean是什么？" class="headerlink" title="Bean是什么？"></a>Bean是什么？</h2><p>本来没有这一节的，但是写完源码之后，在想是否能够类比一下别的更具体的东西，然后想着想着突然想到了个Bean到底是什么？好像用了这么久的Spring，都还没想过这个问题。然后就去看看官网、书、博客等。就有了这一节。</p><blockquote><p>官网的解释：<br><img src="https://img-blog.csdnimg.cn/2021042412285071.png#pic_center"><br><img src="https://img-blog.csdnimg.cn/20210424122858824.png#pic_center"></p></blockquote><blockquote><p>《Spring5核心原理与30个类手写实战》中的解释:<br>Bean对于Spring的意义就像Object对于OOP的意义一样。Spring在Java组件化（JavaBean、EJB等）开发理念下出现的。</p></blockquote><p><strong>个人理解</strong>：<br>Bean是一个组件（对象），组成了我们的应用程序，通过IoC可以对其进行管理。就好比去吃自助餐里面的一道道菜。</p><span id="more"></span><br><br><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><strong>源码中的描述</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20210424113624446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p><strong>大致过程</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20210424113634878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><br><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上图中的核心方法几乎都在doCreateBean()中，我们直接进入到AbstractAutowireCapableBeanFactory类中。<br><img src="https://img-blog.csdnimg.cn/2021042411364973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>首先，进入bean实例的创建，createBeanInstance()方法。</p><p><img src="https://img-blog.csdnimg.cn/20210424113709763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们可以看见上图中Bean可以通过instantiateUsingFactoryMethod()方法创建，也可以通过autowireConstructor()方法创建，但是默认的是使用instantiateBean()方法创建。我们点进去看看</p><p><img src="https://img-blog.csdnimg.cn/20210424113722181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们可以看到这里面有JDK的安全API以及对获取到的bean实例对象进行封装，最重要的是getInstantiationStrategy().instantiate();这个方法。我们继续点进去。</p><p><img src="https://img-blog.csdnimg.cn/20210424113733257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p>是不是看见了个很熟悉的方法？clazz.getDeclaredConstructor();获取构造方法。是不是接下来就会想到了对应的newInstance()？这其实就是在BeanUtils.instantiateClass(constructorToUse);调用了。到此，Bean的实例化出来了，后续就是我们上面说的对Bean实例的封装BeanWrapper了。</p><br><p>接下来，我们进入bean实例对象的属性填充（populateBean()方法）。</p><p><img src="https://img-blog.csdnimg.cn/20210424113745669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>重要的是applyPropertyValues()这个方法，我们点进去看看。</p><p>其中最重要的两个方法是：解析resolveValueIfNecessary()和注入setPropertyValues()方法。</p><p>大致过程是：</p><ol><li><p>属性类型不需要强制转换时，不需要解析属性值，直接进行依赖注入</p></li><li><p>属性值类型需要进行强制转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210424113810697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们进入resolveValueIfNecessary()方法，可以看见这里面有对不同类型属性的解析，感兴趣自己点进去看看。</p><p><img src="https://img-blog.csdnimg.cn/20210424113833856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们进入setPropertyValues()这个方法，到AbstractPropertyAccessor这个类中，我们会发现很多setPropertyValues的重载方法。但是都会走到**setPropertyValue()**这个方法中。<br><img src="https://img-blog.csdnimg.cn/20210424113856389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们继续跟进，还是会发现有很多的setPropertyValue()方法的重载，我靠，怎么这么多！但最后还是会回到这几个方法。这时候，我们属性的依赖注入终于要进行了。我们可以看见主要有3类，对数组类型、对List类型和对Map类型的注入</p><p><img src="https://img-blog.csdnimg.cn/20210424113914313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>到此，我们的属性填充终于终于终于完成了，重载的方法是真的多！</p><p>接下来，我们进入初始化方法（initializeBean()）中。</p><p>在这个里面，我们可以看见上面画的流程图中的大部分方法了。Aware接口、BeanPostProcess和init-method</p><p><img src="https://img-blog.csdnimg.cn/20210424113939423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>Aware接口上面已经贴出来了，就不展示了。</p><p>applyBeanPostProcessorsBeforeInitialization()方法</p><p><img src="https://img-blog.csdnimg.cn/20210424113951793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>invokeInitMethods()方法</p><p><img src="https://img-blog.csdnimg.cn/20210424114004451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>applyBeanPostProcessorsAfterInitialization()方法</p><p><img src="https://img-blog.csdnimg.cn/20210424114014958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>终于要到销毁方法了，在refresh()中的destroyBeans()方法。</p><p>我们点进去，会调用当前BeanFactory的destroySingletons()方法</p><p><img src="https://img-blog.csdnimg.cn/20210424114025145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>调用父类的destroySingletons()方法</p><p><img src="https://img-blog.csdnimg.cn/20210424114034853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p>到此，我们整个Bean的生命周期就结束了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Bean是什么？&quot;&gt;&lt;a href=&quot;#Bean是什么？&quot; class=&quot;headerlink&quot; title=&quot;Bean是什么？&quot;&gt;&lt;/a&gt;Bean是什么？&lt;/h2&gt;&lt;p&gt;本来没有这一节的，但是写完源码之后，在想是否能够类比一下别的更具体的东西，然后想着想着突然想到了个Bean到底是什么？好像用了这么久的Spring，都还没想过这个问题。然后就去看看官网、书、博客等。就有了这一节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网的解释：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021042412285071.png#pic_center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210424122858824.png#pic_center&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;《Spring5核心原理与30个类手写实战》中的解释:&lt;br&gt;Bean对于Spring的意义就像Object对于OOP的意义一样。Spring在Java组件化（JavaBean、EJB等）开发理念下出现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;个人理解&lt;/strong&gt;：&lt;br&gt;Bean是一个组件（对象），组成了我们的应用程序，通过IoC可以对其进行管理。就好比去吃自助餐里面的一道道菜。&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/categories/Code/Spring/"/>
    
    
    <category term="源码" scheme="http://zhaommmmomo.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringIOC大致流程</title>
    <link href="http://zhaommmmomo.cn/2021/04/23/SpringIOC%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B/"/>
    <id>http://zhaommmmomo.cn/2021/04/23/SpringIOC%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B/</id>
    <published>2021-04-23T04:38:02.000Z</published>
    <updated>2021-11-25T13:55:37.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>​    官方文档的解释是：IoC也称为依赖注入（DI）。在此过程中，对象仅通过构造函数参数，工厂方法的参数或在构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即，与它们一起使用的其他对象） 。然后，容器在创建bean时注入那些依赖项。从本质上讲，此过程是通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的Bean本身的逆过程（因此，其名称为Control Inversion）。</p><p>​    简单来说：就是我们将一个个的bean对象交给IoC去管理，他会帮助我们去创建对象实例、填充属性、初始化、添加监听器等过程。</p><span id="more"></span><br><br><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>​    我们以常用的ClassPathXmlApplicationContext为例<br><img src="https://img-blog.csdnimg.cn/2021042312284549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br><br><h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p><img src="https://img-blog.csdnimg.cn/20210423122922215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p>​    首先，一个IoC容器应创建一个工厂（DefaultListableBeanFactory），可以使我们读取的资源文件可以存放。</p><p>​    然后，将配置文件通过一个规范（BeanDefinitionReader）加载出来。</p><p>​    接着，是bean对象实例化之前的一些准备（初始化啊、事件处理器、注册组件等）；例如上图中的BeanFactoryPostProcessor、多播器等。</p><p>​    重要的地方来了，创建一个个的非懒加载的成品Bean对象（finishBeanFactoryInitialization方法）。</p><p>​    最后，是一些事件的发布、缓存、销毁等。</p><br><br><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>​    从ClassPathXmlApplicationContext开始分析。在它的构造方法中，我们可以看见调用了父类（AbstractApplicationContext类）的构造方法、设置配置文件的加载路径以及核心方法refresh()方法。</p><p><img src="https://img-blog.csdnimg.cn/20210423122941651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>​    父类AbstractApplicationContext的构造方法</p><p><img src="https://img-blog.csdnimg.cn/202104231229564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>​    setConfigLocations()方法<br><img src="https://img-blog.csdnimg.cn/20210423123011347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>​    接下来，我们进入核心方法**refresh()**。</p><p><img src="https://img-blog.csdnimg.cn/20210423123024928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>​    我们重点看序号2和序号11，其他有兴趣可以自己点进去看看。</p><p>​    obtainFreshBeanFactory()方法</p><p><img src="https://img-blog.csdnimg.cn/20210423123038255.png#pic_center"></p><p>​    <br></p><p>​    跟进refreshBeanFactory()方法，在AbstractRefreshableApplicationContext类中可以找到refreshBeanFactory()这个方法</p><p><img src="https://img-blog.csdnimg.cn/20210423123102181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>​    createBeanFactory()方法中</p><p><img src="https://img-blog.csdnimg.cn/20210423123124440.png#pic_center"></p><br><p>​    loadBeanDefinitions()方法，也是委派给子类去实现。</p><p><img src="https://img-blog.csdnimg.cn/20210423123136320.png#pic_center"></p><br>    <p>我们进去子类AbstractXmlApplicationContext类的loadBeanDefinition()方法。在这里进行了配置文件读取规范的定义，我们继续跟进loadBeanDefinitions()方法。</p><p><img src="https://img-blog.csdnimg.cn/20210423123153275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>loadBeanDefinitions()方法。传入的可能是个String[]或者Resource[]类型。但是大致流程都差不多：String[]-&gt;String-&gt;Resource[]-&gt;Resource-&gt;Document-&gt;BeanDefinition。这里就不过多深入了，感兴趣可以照这个流程看下去。</p><p><img src="https://img-blog.csdnimg.cn/2021042312342942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>资源文件加载完成后，我们的BeanFactory差不多就创建好了。接着，我们到IoC最重要的过程，Bean对象（不是懒加载的）的实例化和初始化。这里为什么将实例化和初始化分开说呢，是想更好的帮助理解Bean对象的创建过程。其实Spring中更加的细分了一下，分成了<strong>实例化（createBeanInstance()方法）、填充属性（populateBean()方法）和初始化（initializeBean()方法）。</strong></p><p>​    <strong>实例化</strong>：在堆中开辟了一块空间。属性都是系统默认值。</p><p>​    <strong>初始化</strong>：给属性完成具体的赋值操作，调用具体的初始化方法。</p><p>​    好了，我们进入finishBeanFactoryInitialization()方法，里面你会看到一些对beanFactory的属性设置，其中重点的是preInstantiateSingletons()方，点进去，它会调用DefaultListableBeanFactory的preInstantiateSingletons()方法。</p><p><img src="https://img-blog.csdnimg.cn/20210423123441986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>我们可以看到**getBean()**方法，这里就是准备开始进行bean对象的创建了。</p><p>点进去，我们可以看真正执行的是**doGetBean()**方法</p><p><img src="https://img-blog.csdnimg.cn/20210423123455791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>doGetBean()方法，就是根据不同的Bean采用不同的创建策略。</p><ol><li><p>如果Bean是<strong>单例</strong>的，则在容器创建之前先从缓存中查找，确保整个容器只存在一个实例对象</p></li><li><p>如果Bean是<strong>原型模式</strong>的，则容器每次都会创建一个新的实例对象</p><ol start="3"><li> <strong>指定了Bean的生命周期</strong></li></ol></li></ol><p><img src="https://img-blog.csdnimg.cn/20210423123506408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/20210423123521810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>​    我们进入createBean()，发现还有一个doCreateBean方法()，终于，我们到了真正创建Bean对象的方法。点进去。</p><p><img src="https://img-blog.csdnimg.cn/20210423123535530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><br><p>​    我们发现我们终于找到了之前所说的那三个方法了，创建、填充和初始化。</p><p>​    createBeanInstance()方法返回的是一个BeanWrapper，bean的封装类。</p><p>​    populateBean()则是将bean的一些属性字段进行解析、填充。</p><p>​    在initializeBean()中</p><p><img src="https://img-blog.csdnimg.cn/20210423123559468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><p>到此，我们一开始的流程图所有的地方差不多都完成了。其中有些细节方面没点进去看看，主要是大致了解IoC的过程。可以自行debug进去看看。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;是什么？&quot;&gt;&lt;a href=&quot;#是什么？&quot; class=&quot;headerlink&quot; title=&quot;是什么？&quot;&gt;&lt;/a&gt;是什么？&lt;/h2&gt;&lt;p&gt;​    官方文档的解释是：IoC也称为依赖注入（DI）。在此过程中，对象仅通过构造函数参数，工厂方法的参数或在构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即，与它们一起使用的其他对象） 。然后，容器在创建bean时注入那些依赖项。从本质上讲，此过程是通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的Bean本身的逆过程（因此，其名称为Control Inversion）。&lt;/p&gt;
&lt;p&gt;​    简单来说：就是我们将一个个的bean对象交给IoC去管理，他会帮助我们去创建对象实例、填充属性、初始化、添加监听器等过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/categories/Code/Spring/"/>
    
    
    <category term="源码" scheme="http://zhaommmmomo.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>循环依赖</title>
    <link href="http://zhaommmmomo.cn/2021/04/22/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://zhaommmmomo.cn/2021/04/22/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2021-04-22T03:06:14.000Z</published>
    <updated>2021-11-25T13:55:37.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>简单的来说就是对象a的属性中引用了对象b，对象b的属性中引用了对象c……最后引用到a。</p><p><img src="https://img-blog.csdnimg.cn/20210422105710598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zmm.test.A&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;b&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zmm.test.B&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;c&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;c&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zmm.test.C&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><br><br><h2 id="Spring是如何解决的？"><a href="#Spring是如何解决的？" class="headerlink" title="Spring是如何解决的？"></a>Spring是如何解决的？</h2><h3 id="1-三级缓存（其实二级缓存也能解决，只是看是否使用AOP）"><a href="#1-三级缓存（其实二级缓存也能解决，只是看是否使用AOP）" class="headerlink" title="1. 三级缓存（其实二级缓存也能解决，只是看是否使用AOP）"></a>1. 三级缓存（其实二级缓存也能解决，只是看是否使用AOP）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSingletonBeanRegistry类下的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *一级缓存</span></span><br><span class="line"><span class="comment"> *用来存放成品bean对象（已经成功实例化与初始化了的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Cache of singleton objects: bean name to bean instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *三级缓存 （AOP的关键，如果不用AOP，二级缓存也能解决循环依赖）</span></span><br><span class="line"><span class="comment"> * 用来存放早期的bean实例(lambda表达式，一个匿名内部类的形式)，看bean对象是否需要被代理。</span></span><br><span class="line"><span class="comment"> * ObjectFactory&lt;?&gt;是一个函数式接口，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Cache of singleton factories: bean name to ObjectFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *二级缓存</span></span><br><span class="line"><span class="comment"> * 用来存放半成品bean对象，已经实例化了的但是未初始化的bean对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Cache of early singleton objects: bean name to bean instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><br><h3 id="2-提前暴露"><a href="#2-提前暴露" class="headerlink" title="2.提前暴露"></a>2.提前暴露</h3><p>AbstractAutowireCapableBeanFactory类的doCreateBean()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">// 急于缓存单例，以便即使在诸如BeanFactoryAware之类的生命周期接口触发时也能够解析循环引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是单例的 &amp;&amp; 允许循环引用 &amp;&amp; 是Singleton当前bean正在创作中</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个匿名内部类，提前暴露创建的实例bean。可以防止循环引用，尽早的持有对象的引用</span></span><br><span class="line">        <span class="comment">// 如果一级缓存中不存在指定的bean，就添加到三级缓存中去，将二级缓存中的移除</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ........................</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是提前暴露的单例</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 获取指定名称的已注册的单例模式的Bean对象</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果获取到的bean对象不为空</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 如果获取到的Bean对象与当前实例化的Bean对象相同</span></span><br><span class="line">                <span class="comment">// 将实例暴露出去，当前实例初始化完成</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前Bean依赖其他Bean，并且当发生循环引用时不允许创建新的实例对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="comment">// 获取当前Bean所依赖的其他Bean</span></span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// .......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionValueResolver类下的resolveValueIfNecessary()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析属性值，对注入类型进行转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, <span class="meta">@Nullable</span> Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对引用类型的属性进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">        RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">        <span class="comment">// 调用引用类型的解析方法</span></span><br><span class="line">        <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......对其他类型的属性的解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p><img src="https://img-blog.csdnimg.cn/20210422105744532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p><p>​    </p><br><br><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>A引用B、B引用C、C引用A。根据上面大致流程来。在docreate()方法中，先对<strong>a实例化</strong><br><img src="https://img-blog.csdnimg.cn/20210422105923815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210422110015558.png"></p><br><p>将a实例的引用<strong>暴露</strong>出去</p><p><img src="https://img-blog.csdnimg.cn/20210422110032589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210422110046239.png"></p><br><p>准备去填充属性，进入populateBean()方法，applyPropertyValues()方法继续进入，重点来了，resolveValueIfNecessary()方法</p><p><img src="https://img-blog.csdnimg.cn/20210422110103437.png"></p><br><p>继续进入，我们会看到会调用resolveReference()这个方法</p><p><img src="https://img-blog.csdnimg.cn/20210422110116747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p><br><p>最终又会调用**getBean()**方法<br><img src="https://img-blog.csdnimg.cn/20210422110254267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p><br><p>接下来我就省略对b的实例化，直接去看对c的。<br><img src="https://img-blog.csdnimg.cn/2021042211031461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p><br><p>继续跟着上面的走，在BeanDefinitionValueResolver类的resolveReference()方法时，调用getBean()去获取了a的实例<br><img src="https://img-blog.csdnimg.cn/2021042211035726.png"></p><br><p>从缓存中获取a的实例</p><p><img src="https://img-blog.csdnimg.cn/20210422110413375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p><br><p>我们继续跟进到c实例的doGetBean()方法</p><p><img src="https://img-blog.csdnimg.cn/20210422110426786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p><p>这时候，c的实例化初始化已经完成了，然后就是b的初始化以及a的初始化了，步骤类似，自行去debug吧。</p><br><br><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>1、在三级缓存中，实例的变更情况。例如a、b、c。序号代表顺序</p><p>一级缓存：7.添加c、9.添加b、11.添加a</p><p>二级缓存：4.添加a、10.移除a</p><p>三级缓存：1.添加a、2.添加b、3.添加c、5.移除a、6.移除c、8.移除b</p><p>2、关于构造器注入和set注入，下面是官网的解释<br><img src="https://img-blog.csdnimg.cn/20210424101132182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;是什么？&quot;&gt;&lt;a href=&quot;#是什么？&quot; class=&quot;headerlink&quot; title=&quot;是什么？&quot;&gt;&lt;/a&gt;是什么？&lt;/h2&gt;&lt;p&gt;简单的来说就是对象a的属性中引用了对象b，对象b的属性中引用了对象c……最后引用到a。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210422105710598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;com.zmm.test.A&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;lazy-init&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;com.zmm.test.B&amp;quot;&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;lazy-init&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;com.zmm.test.C&amp;quot;&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;lazy-init&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/categories/Code/Spring/"/>
    
    
    <category term="源码" scheme="http://zhaommmmomo.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Spring" scheme="http://zhaommmmomo.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://zhaommmmomo.cn/2021/04/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://zhaommmmomo.cn/2021/04/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-04-04T04:30:56.000Z</published>
    <updated>2021-11-25T13:55:38.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    前一个月开始刷题，那会儿在力扣上面，见一个DP题一个不会的。突然觉得自己好垃圾哈哈哈。为什么现在写这个呢，就刚刚刷着刷着题，突发奇想了，觉得好像找到了哪个感觉？开始刷DP过瘾了哈哈哈。但是我又不太会讲，直接来分享我对一些DP案例题的解题思路。不多说，进入正题。</p><span id="more"></span><p><br><br></p><h2 id="案例-其他几个案例整理出来后补上"><a href="#案例-其他几个案例整理出来后补上" class="headerlink" title="案例(其他几个案例整理出来后补上)"></a>案例(其他几个案例整理出来后补上)</h2><h3 id="青蛙跳级问题"><a href="#青蛙跳级问题" class="headerlink" title="青蛙跳级问题"></a>青蛙跳级问题</h3><blockquote><p>一个青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。</p></blockquote><p><strong>思考</strong></p><ol><li><p>青蛙跳级的方式有2种：</p><ul><li>跳1个台阶</li><li>跳2个台阶</li></ul></li><li><p>将问题转变为数学函数：<br><img src="https://img-blog.csdnimg.cn/20210404123002861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptbV9fMTM3NzQ0NTI5Mg==,size_16,color_FFFFFF,t_70"></p></li></ol><br><p><strong>解题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] + res[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>拓展</strong></p><ul><li><p><strong>如果小青蛙有三种跳法呢？跳一个台阶、跳两个台阶、跳三个台阶呢？</strong></p></li><li><p><strong>斐波那契数列</strong></p></li><li><p><a href="https://leetcode-cn.com/problems/edit-distance/">力扣72题</a></p></li></ul><br><br><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><blockquote><p>假如你有一个可以装5kg的背包，你去商城里面得将最有价值的物品装进背包，但是不能超过背包容量。求你能带走的最大价值的总和</p><p>商场中的物品有：</p><table><thead><tr><th align="center">物品</th><th align="center">重量</th><th align="center">价值</th></tr></thead><tbody><tr><td align="center">铅笔</td><td align="center">0.5kg</td><td align="center">1</td></tr><tr><td align="center">面包</td><td align="center">1kg</td><td align="center">3</td></tr><tr><td align="center">手电筒</td><td align="center">3kg</td><td align="center">10</td></tr><tr><td align="center">水</td><td align="center">2kg</td><td align="center">7</td></tr></tbody></table></blockquote><p><strong>思考</strong></p><p>平常我们遇到这种问题，都是想着先把性价比最高的拿了，然后拿第二的，但是在某些场景下就不太适合了。这里就不太过多讲解，主要使用动态规划来解这道题目。</p><table><thead><tr><th align="center">物品</th><th align="center">0.5kg</th><th align="center">1kg</th><th align="center">2kg</th><th align="center">3kg</th><th align="center">4kg</th><th align="center">5kg</th></tr></thead><tbody><tr><td align="center">铅笔</td><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">6</td><td align="center">8</td><td align="center">10</td></tr><tr><td align="center">面包</td><td align="center">1</td><td align="center">3</td><td align="center">6</td><td align="center">9</td><td align="center">12</td><td align="center">15</td></tr><tr><td align="center">手电筒</td><td align="center">1</td><td align="center">3</td><td align="center">6</td><td align="center">10</td><td align="center">13</td><td align="center">16</td></tr><tr><td align="center">水</td><td align="center">1</td><td align="center">3</td><td align="center">7</td><td align="center">10</td><td align="center">14</td><td align="center">17</td></tr></tbody></table><br><p><strong>主要思路：将每一阶段重量的最优解保存</strong></p><p><img src="https://img-blog.csdnimg.cn/20210404122915337.png"></p><p>例如：</p><ul><li><strong>当只有铅笔的时候：</strong>    0.5kg的最优解是1、1kg的最优解是2……5kg的最优解是10</li><li><strong>当有铅笔和面包的时候：</strong>0.5kg的最优解是1、1kg的最优解是3……5kg的最优解是15</li><li>……</li><li><strong>当全部物品都在时：</strong>0.5kg的最优解是1、1kg的最优解是3……5kg的最优解是17</li></ul><p>我们这时就能得到最终答案为17</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    前一个月开始刷题，那会儿在力扣上面，见一个DP题一个不会的。突然觉得自己好垃圾哈哈哈。为什么现在写这个呢，就刚刚刷着刷着题，突发奇想了，觉得好像找到了哪个感觉？开始刷DP过瘾了哈哈哈。但是我又不太会讲，直接来分享我对一些DP案例题的解题思路。不多说，进入正题。&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://zhaommmmomo.cn/categories/Code/"/>
    
    <category term="刷题" scheme="http://zhaommmmomo.cn/categories/Code/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="刷题" scheme="http://zhaommmmomo.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法" scheme="http://zhaommmmomo.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
