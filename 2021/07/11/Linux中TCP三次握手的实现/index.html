<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux中TCP三次握手的实现 - zmm&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="zhaommmmomo"><meta name="msapplication-TileImage" content="/img/logo.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="zhaommmmomo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言网上三次握手八股文一大堆，我“为了面试”也去看了看，刚好那时候接触Linux比较多，突然想到TCP三次握手在Linux内核中是如何去实现的呢？是不是会有不同？然后我就开始了漫长的百度（ps: 我比较菜，还不能拿着Linux上千个源码文件去怼）、源码之路。终于弄清了Linux中TCP三次握手的大致过程。"><meta property="og:type" content="blog"><meta property="og:title" content="Linux中TCP三次握手的实现"><meta property="og:url" content="http://zhaommmmomo.cn/2021/07/11/Linux%E4%B8%ADTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="zmm&#039;s blog"><meta property="og:description" content="前言网上三次握手八股文一大堆，我“为了面试”也去看了看，刚好那时候接触Linux比较多，突然想到TCP三次握手在Linux内核中是如何去实现的呢？是不是会有不同？然后我就开始了漫长的百度（ps: 我比较菜，还不能拿着Linux上千个源码文件去怼）、源码之路。终于弄清了Linux中TCP三次握手的大致过程。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/d6665e364dc54466a16871c5613e2311.png#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/8323f56c928a41728d7cec206c821c6b.png#pic_center"><meta property="article:published_time" content="2021-07-11T00:41:04.000Z"><meta property="article:modified_time" content="2021-11-25T13:55:37.727Z"><meta property="article:author" content="zhaommmmomo"><meta property="article:tag" content="源码"><meta property="article:tag" content="Linux"><meta property="article:tag" content="TCP"><meta property="article:tag" content="Linux网络"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://img-blog.csdnimg.cn/d6665e364dc54466a16871c5613e2311.png#pic_center"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://zhaommmmomo.cn/2021/07/11/Linux%E4%B8%ADTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"},"headline":"Linux中TCP三次握手的实现","image":[],"datePublished":"2021-07-11T00:41:04.000Z","dateModified":"2021-11-25T13:55:37.727Z","author":{"@type":"Person","name":"zhaommmmomo"},"publisher":{"@type":"Organization","name":"zmm's blog","logo":{"@type":"ImageObject","url":"http://zhaommmmomo.cn/img/logo.jpg"}},"description":"前言网上三次握手八股文一大堆，我“为了面试”也去看了看，刚好那时候接触Linux比较多，突然想到TCP三次握手在Linux内核中是如何去实现的呢？是不是会有不同？然后我就开始了漫长的百度（ps: 我比较菜，还不能拿着Linux上千个源码文件去怼）、源码之路。终于弄清了Linux中TCP三次握手的大致过程。"}</script><link rel="canonical" href="http://zhaommmmomo.cn/2021/07/11/Linux%E4%B8%ADTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"><link rel="alternate" href="/atom.xml" title="zmm&#039;s blog" type="application/atom+xml"><link rel="icon" href="/img/logo.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="zmm&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/books">书架</a><a class="navbar-item" href="/paper">论文</a><a class="navbar-item" href="/resume">个人简历</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://www.github.com/zhaommmmomo"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-11T00:41:04.000Z" title="7/11/2021, 8:41:04 AM">2021-07-11</time>发表</span><span class="level-item"> zhaommmmomo </span><span class="level-item"><a class="link-muted" href="/categories/Code/">Code</a><span> / </span><a class="link-muted" href="/categories/Code/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Code/Linux/%E7%BD%91%E7%BB%9C/">网络</a></span><span class="level-item">1 小时读完 (大约6915个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Linux中TCP三次握手的实现</h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上三次握手八股文一大堆，我“为了面试”也去看了看，刚好那时候接触Linux比较多，突然想到<code>TCP三次握手在Linux内核中是如何去实现的呢</code>？是不是会有不同？然后我就开始了漫长的百度（ps: 我比较菜，还不能拿着Linux上千个源码文件去怼）、源码之路。终于弄清了Linux中TCP三次握手的大致过程。</p>
<span id="more"></span>

<br>

<br>

<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我那边都知道TCP建立连接前都需要客户端发送一个SYN包，服务端响应一个SYN + ACK包，客户端响应一个ACK包，这是三次握手的基本流程。</p>
<p><img src="https://img-blog.csdnimg.cn/d6665e364dc54466a16871c5613e2311.png#pic_center"></p>
<p>但如果让我们去实现三次握手，应该怎么去设计呢？</p>
<br>

<br>

<h2 id="Linux中的实现"><a href="#Linux中的实现" class="headerlink" title="Linux中的实现"></a>Linux中的实现</h2><p>我们以网络编程中的相应函数为切入点</p>
<p>Linux中三次握手的主要函数有socket()、bind()、listen()、connect()、recv()、accept()</p>
<p><img src="https://img-blog.csdnimg.cn/8323f56c928a41728d7cec206c821c6b.png#pic_center"></p>
<br>

<h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><p>socket 在内核里并不是一个内核对象。而是包含 file、socket、sock 等多个相关内核对象构成，每个内核对象还定义了 ops 操作函数集合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的是一个文件描述符fd</span></span><br><span class="line">fd = socket(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>





<br>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>调用bind()函数绑定端口，会使connect()时选择端口方式无效。不推荐在客户端中使用bind()，这会打乱connect的端口选择过程。（但某些情况下可能会bind()，比如说在服务端和客户端进行协商使用什么端口来调用）</p>
<p><strong>流程：</strong></p>
<ol>
<li><p>判断用户传入的端口是否小于1024</p>
</li>
<li><p>调用inet_csk_get_port来判断传入端口是否被占用，如果被占用就返回EADDRINUSE。这个方法不会到 ESTABLISH 的哈希表进行可用检测，只在 bind 状态的 socket 里查。所以<strong>默认情况下，只要端口用过一次就不会再次使用</strong>。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/af_inet.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_bind</span><span class="params">(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =</span> (struct sockaddr_in *)uaddr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> snum;</span><br><span class="line">	<span class="keyword">int</span> chk_addr_ret;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;</span><br><span class="line">        <span class="comment">// 如果这个socket有他自己的bind()函数，就使用这个bind()函数</span></span><br><span class="line">		err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用户传入的端口号</span></span><br><span class="line">	snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">	err = -EACCES;</span><br><span class="line">	<span class="comment">// 传入的端口号不允许小于1024</span></span><br><span class="line">	<span class="keyword">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp; !capable(CAP_NET_BIND_SERVICE))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 尝试确定端口号</span></span><br><span class="line">    <span class="comment">// 实际调用的是inet_csk_get_port，用来尝试确定端口号是否被占用</span></span><br><span class="line">    <span class="comment">// 如果被占用就返回EADDRINUSE，然后就会显示&quot;Address already in use&quot;(端口被占用)</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">		inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">		err = -EADDRINUSE;</span><br><span class="line">		<span class="keyword">goto</span> out_release_sock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/inet_connection_sock.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	获取对给定sock的本地端口的引用，</span></span><br><span class="line"><span class="comment"> *  如果snum为零，则表示选择任何可用的本地端口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_get_port</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">short</span> snum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span> =</span> sk-&gt;sk_prot-&gt;h.hashinfo;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> *<span class="title">tb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret, attempts = <span class="number">5</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	<span class="keyword">int</span> smallest_size = <span class="number">-1</span>, smallest_rover;</span><br><span class="line"></span><br><span class="line">	local_bh_disable();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果传入的snum不为0</span></span><br><span class="line">	<span class="keyword">if</span> (!snum) &#123;</span><br><span class="line">		<span class="keyword">int</span> remaining, rover, low, high;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">		<span class="comment">// 获取本地指定的端口范围</span></span><br><span class="line">		inet_get_local_port_range(&amp;low, &amp;high);</span><br><span class="line">		remaining = (high - low) + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 在端口范围中取一个随机位置开始遍历</span></span><br><span class="line">		smallest_rover = rover = net_random() % remaining + low;</span><br><span class="line"></span><br><span class="line">		smallest_size = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果本地设置了一个端口不可用</span></span><br><span class="line">			<span class="keyword">if</span> (inet_is_reserved_local_port(rover))</span><br><span class="line">				<span class="keyword">goto</span> next_nolock;</span><br><span class="line">            </span><br><span class="line">			head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, rover,</span><br><span class="line">					hashinfo-&gt;bhash_size)];</span><br><span class="line">			spin_lock(&amp;head-&gt;lock);</span><br><span class="line">			inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 冲突检测，如果端口是用到的，去have_sum逻辑</span></span><br><span class="line">				<span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == rover) &#123;</span><br><span class="line">					<span class="keyword">if</span> (tb-&gt;fastreuse &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">					    sk-&gt;sk_reuse &amp;&amp;</span><br><span class="line">					    sk-&gt;sk_state != TCP_LISTEN &amp;&amp;</span><br><span class="line">					    (tb-&gt;num_owners &lt; smallest_size || smallest_size == <span class="number">-1</span>)) &#123;</span><br><span class="line">						smallest_size = tb-&gt;num_owners;</span><br><span class="line">						smallest_rover = rover;</span><br><span class="line">						<span class="keyword">if</span> (atomic_read(&amp;hashinfo-&gt;bsockets) &gt; (high - low) + <span class="number">1</span>) &#123;</span><br><span class="line">							spin_unlock(&amp;head-&gt;lock);</span><br><span class="line">							snum = smallest_rover;</span><br><span class="line">							<span class="keyword">goto</span> have_snum;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">goto</span> next;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		next:</span><br><span class="line">			spin_unlock(&amp;head-&gt;lock);</span><br><span class="line">		next_nolock:</span><br><span class="line">			<span class="keyword">if</span> (++rover &gt; high)</span><br><span class="line">				rover = low;</span><br><span class="line">		&#125; <span class="keyword">while</span> (--remaining &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Exhausted local port range during search?  It is not</span></span><br><span class="line"><span class="comment">		 * possible for us to be holding one of the bind hash</span></span><br><span class="line"><span class="comment">		 * locks if this test triggers, because if &#x27;remaining&#x27;</span></span><br><span class="line"><span class="comment">		 * drops to zero, we broke out of the do/while loop at</span></span><br><span class="line"><span class="comment">		 * the top level, not from the &#x27;break;&#x27; statement.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (smallest_size != <span class="number">-1</span>) &#123;</span><br><span class="line">				snum = smallest_rover;</span><br><span class="line">				<span class="keyword">goto</span> have_snum;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* OK, here is the one we will use.  HEAD is</span></span><br><span class="line"><span class="comment">		 * non-NULL and we hold it&#x27;s mutex.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		snum = rover;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">have_snum:</span><br><span class="line">		head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, snum,</span><br><span class="line">				hashinfo-&gt;bhash_size)];</span><br><span class="line">		spin_lock(&amp;head-&gt;lock);</span><br><span class="line">		inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)</span><br><span class="line">			<span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == snum)</span><br><span class="line">                <span class="comment">// 判断端口是否被占用</span></span><br><span class="line">				<span class="keyword">goto</span> tb_found;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<h3 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h3><p><strong>主要是申请和初始化接收队列，包括全连接队列和半连接队列</strong></p>
<p><strong>全连接队列长度：</strong>用户传入的 backlog 和 net.core.somaxconn 之间较小的那个值</p>
<p><strong>半连接队列长度：</strong>min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再上取整到 2 的幂次，但最小不能小于16。</p>
<p><strong>流程：</strong></p>
<ol>
<li>根据文件描述符fd查找socket内核对象</li>
<li>获取内核参数net.core.somaxconn，与用户传入的backlog相比较，取最小的</li>
<li>调用sock-&gt;ops-&gt;listen(sock, backlog)函数，实际是inet_listen</li>
<li>判断是否是listen状态<ul>
<li>如果不是listen状态，<strong>开始监听（接收队列的创建、初始化。内存申请、半连接队列长度的计算、全连接队列头的初始化等）</strong>。1. 计算半连接队列长度（<strong>与sysctl_max_syn_backlog取 一次最小值；保证不能比8小；向上对齐到2的整数次幂</strong>）。2. 申请内存。3. 全队列头初始化，设置为null。4. 将半连接队列挂载到接收队列上。</li>
</ul>
</li>
<li>设置<strong>全连接队列的长度（backlog与net.core.somaxconn之间较小的哪个值）</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/socket.c</span></span><br><span class="line">SYSCALL_DEFINE2(listen, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, backlog)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err, fput_needed;</span><br><span class="line">	<span class="keyword">int</span> somaxconn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据 fd（文件描述符） 查找对应的 socket 内核对象</span></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (sock) &#123;</span><br><span class="line">		<span class="comment">// 获取内核参数</span></span><br><span class="line">		somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line">		<span class="comment">// 如果设置的backlog大于核心参数</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span>)backlog &gt; somaxconn)</span><br><span class="line">			<span class="comment">// 使用核心参数</span></span><br><span class="line">			backlog = somaxconn;</span><br><span class="line"></span><br><span class="line">		err = security_socket_listen(sock, backlog);</span><br><span class="line">		<span class="keyword">if</span> (!err)</span><br><span class="line">			<span class="comment">// 调用协议栈注册的listen函数</span></span><br><span class="line">			err = sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line"></span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="comment">// 服务端的全连接队列长度是listen时传入的backlog和net.core.somaxconn之间最小的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_listen</span><span class="params">(struct socket *sock, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 还不是listen状态（没有listen过）</span></span><br><span class="line">	<span class="keyword">if</span> (old_state != TCP_LISTEN) &#123;</span><br><span class="line">		<span class="comment">// 开始监听</span></span><br><span class="line">		err = inet_csk_listen_start(sk, backlog);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置全连接队列长度</span></span><br><span class="line">	sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/inet_connection_sock.c</span></span><br><span class="line"><span class="comment">// 用来初始化接收队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_listen_start</span><span class="params">(struct sock *sk, <span class="keyword">const</span> <span class="keyword">int</span> nr_table_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用来申请和初始化icsk_accept_queue（半连接队列和全连接队列）这个对象</span></span><br><span class="line">    <span class="comment">// 1.定义接收队列数据结构</span></span><br><span class="line">	<span class="comment">// 2.接收队列的申请和初始化（内存的申请、半连接队列长度的计算、全连接队列头的初始化）</span></span><br><span class="line">    <span class="keyword">int</span> rc = reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue, nr_table_entries);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/core/request_sock.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * queue：用来存放全连接和半连接队列的结构体</span></span><br><span class="line"><span class="comment"> * nr_table_entries：是内核参数和用户传入的backlog中的最小值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 定义一个listen_sock指针（半连接队列）</span></span><br><span class="line"><span class="comment"> * 2. 计算半连接队列的长度，然后申请内存。半连接队列的长度是 min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再上取整到 2 的幂次，但最小不能小于16。 </span></span><br><span class="line"><span class="comment"> * 3. 将全连接队列头queue-&gt;rskq_accept_head设置成NULL，</span></span><br><span class="line"><span class="comment"> * 	  将半连接队列挂载到接收队列queue上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reqsk_queue_alloc</span><span class="params">(struct request_sock_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_table_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> lopt_size = <span class="keyword">sizeof</span>(struct listen_sock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 半连接队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listen_sock</span> *<span class="title">lopt</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算半连接队列的长度</span></span><br><span class="line">	<span class="comment">// 再次和sysctl_max_syn_backlog内核对象又取一次最小值</span></span><br><span class="line">	nr_table_entries = <span class="keyword">min_t</span>(u32, nr_table_entries, sysctl_max_syn_backlog);</span><br><span class="line">	<span class="comment">// 保证nr_table_entries不能比8小。</span></span><br><span class="line">	nr_table_entries = <span class="keyword">max_t</span>(u32, nr_table_entries, <span class="number">8</span>);</span><br><span class="line">	<span class="comment">// 用来上对齐到2的整数次幂</span></span><br><span class="line">	<span class="comment">// 比如说当前nr_table_entries是最小值8</span></span><br><span class="line">	<span class="comment">// 经过roundup_pow_of_two（8+1） = 16</span></span><br><span class="line">	nr_table_entries = roundup_pow_of_two(nr_table_entries + <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 为listen_sock对象申请内存，这里包含了半连接队列</span></span><br><span class="line">	lopt_size += nr_table_entries * <span class="keyword">sizeof</span>(struct request_sock *);</span><br><span class="line">	<span class="keyword">if</span> (lopt_size &gt; PAGE_SIZE)</span><br><span class="line">		lopt = vzalloc(lopt_size);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		lopt = kzalloc(lopt_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (lopt == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了效率，不记录nr_table_entries</span></span><br><span class="line">	<span class="comment">// 而是记录2的几次幂等于nr_table_entries</span></span><br><span class="line">    <span class="comment">// t</span></span><br><span class="line">	<span class="keyword">for</span> (lopt-&gt;max_qlen_log = <span class="number">3</span>;</span><br><span class="line">	     (<span class="number">1</span> &lt;&lt; lopt-&gt;max_qlen_log) &lt; nr_table_entries;</span><br><span class="line">	     lopt-&gt;max_qlen_log++);</span><br><span class="line"></span><br><span class="line">	get_random_bytes(&amp;lopt-&gt;hash_rnd, <span class="keyword">sizeof</span>(lopt-&gt;hash_rnd));</span><br><span class="line">	rwlock_init(&amp;<span class="built_in">queue</span>-&gt;syn_wait_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全连接队列头初始化</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;rskq_accept_head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 半连接队列设置</span></span><br><span class="line">	lopt-&gt;nr_table_entries = nr_table_entries;</span><br><span class="line">	write_lock_bh(&amp;<span class="built_in">queue</span>-&gt;syn_wait_lock);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;listen_opt = lopt;</span><br><span class="line">	write_unlock_bh(&amp;<span class="built_in">queue</span>-&gt;syn_wait_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<br>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p><strong>流程：</strong></p>
<ol>
<li>进入内核系统根据用户传入的fd（文件描述符）来查询对应的socket内核对象</li>
<li>调用该sock对象的sock-&gt;ops-&gt;connect方法（inet_stream_connect）</li>
<li>根据sock的状态来进入不同的处理逻辑。第一次connect，sock的状态都是unconnect，所以会调sk-&gt;sk_prot-&gt;connect方法（tcp_v4_connect）</li>
<li>将socket状态设置为TCP-SYN-SENT</li>
<li>动态选择一个端口（首先判断<strong>是否bind()了一个端口</strong>，如果没有，就根据目标地址和端口等信息生成一个随机数，然后在本地端口范围中通过这个随机数逐渐增加遍历，如果是本地配置的保留端口就跳过，如果不是就遍历已经使用的端口的<strong>哈希链表（hinfo-&gt;bhash）</strong>，判断是否已经被使用。如果<strong>该端口已经被使用并且<code>TCP连接中的四元组与当前建立的四元组完全一致</code>，就不可使用</strong>。继续遍历，找到了就返回端口，没找到就提示”Address already in use”）</li>
<li>进行tcp连接。（首先申请并设置skb，然后添加到发送队列sk_write_queue上，进行发送，启动重传定时器）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/socket.c</span></span><br><span class="line">SYSCALL_DEFINE3(connect, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,</span><br><span class="line">		<span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据用户fd查找内核中的socket对象</span></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用sock中ops的connect()方法</span></span><br><span class="line">    <span class="comment">// 其实是inet_stream_connect()</span></span><br><span class="line">	err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,</span><br><span class="line">				 sock-&gt;file-&gt;f_flags);</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: ipv4/af_inet.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_stream_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">case</span> SS_CONNECTED:</span><br><span class="line">		err = -EISCONN;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">case</span> SS_CONNECTING:</span><br><span class="line">		err = -EALREADY;</span><br><span class="line">		<span class="comment">/* Fall out of switch with err, set for this state */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line">	<span class="comment">// 刚创建完的socket状态就是SS_UNCONNECTED，</span></span><br><span class="line">    <span class="comment">// 所以第一次connect的就会走这个case</span></span><br><span class="line">		err = -EISCONN;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用sock的tcp_v4_connect方法</span></span><br><span class="line">		err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 修改sock的状态</span></span><br><span class="line">		sock-&gt;state = SS_CONNECTING;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Just entered SS_CONNECTING state; the only</span></span><br><span class="line"><span class="comment">		 * difference is that return value in non-blocking</span></span><br><span class="line"><span class="comment">		 * case is EINPROGRESS, rather than EALREADY.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		err = -EINPROGRESS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 启动传出连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_connect</span><span class="params">(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 设置socket状态为TCP_SYN_SENT</span></span><br><span class="line">	tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 动态选择一个端口</span></span><br><span class="line">	err = inet_hash_connect(&amp;tcp_death_row, sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 函数用来根据sk中的信息，构建一个完成的syn报文，并将它发送出去</span></span><br><span class="line">	err = tcp_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file:net/ipv4/inet_hashtables.c</span></span><br><span class="line"><span class="comment">// 绑定一个端口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_hash_connect</span><span class="params">(struct inet_timewait_death_row *death_row,</span></span></span><br><span class="line"><span class="params"><span class="function">		      struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// inet_sk_port_offset(sk): 根据要连接的目的IP和端口等信息生成一个随机数</span></span><br><span class="line">	<span class="comment">// __inet_check_established: 检查是否和现有 ESTABLISH 的连接是否冲突的时候用的函数</span></span><br><span class="line">	<span class="keyword">return</span> __inet_hash_connect(death_row, sk, inet_sk_port_offset(sk),</span><br><span class="line">			__inet_check_established, __inet_hash_nolisten);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file:net/ipv4/inet_hashtables.c</span></span><br><span class="line"><span class="comment">// 端口号选择</span></span><br><span class="line"><span class="keyword">int</span> __inet_hash_connect(struct inet_timewait_death_row *death_row,</span><br><span class="line">		struct sock *sk, u32 port_offset,</span><br><span class="line">		<span class="keyword">int</span> (*check_established)(struct inet_timewait_death_row *,</span><br><span class="line">			struct sock *, __u16, struct inet_timewait_sock **),</span><br><span class="line">		<span class="keyword">int</span> (*hash)(struct sock *sk, struct inet_timewait_sock *twp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hinfo</span> =</span> death_row-&gt;hashinfo;</span><br><span class="line">	<span class="comment">// 是否绑定过端口（bind()方法）</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> snum = inet_sk(sk)-&gt;inet_num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> *<span class="title">tb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	<span class="keyword">int</span> twrefcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有绑定端口</span></span><br><span class="line">	<span class="keyword">if</span> (!snum) &#123;</span><br><span class="line">		<span class="keyword">int</span> i, remaining, low, high, port;</span><br><span class="line">		<span class="keyword">static</span> u32 hint;</span><br><span class="line">		u32 offset = hint + port_offset;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">node</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_timewait_sock</span> *<span class="title">tw</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取本机的端口范围信息</span></span><br><span class="line">		inet_get_local_port_range(&amp;low, &amp;high);</span><br><span class="line">		remaining = (high - low) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		local_bh_disable();</span><br><span class="line">		<span class="comment">// 遍历查找端口</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= remaining; i++) &#123;</span><br><span class="line">            <span class="comment">// 之前算出的随机数+i</span></span><br><span class="line">			port = low + (i + offset) % remaining;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果本机配置了该端口不可用</span></span><br><span class="line">			<span class="keyword">if</span> (inet_is_reserved_local_port(port))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 查找和遍历已经使用的端口的哈希链表</span></span><br><span class="line">			head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port,</span><br><span class="line">					hinfo-&gt;bhash_size)];</span><br><span class="line">			spin_lock(&amp;head-&gt;lock);</span><br><span class="line"></span><br><span class="line">			inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) &#123;</span><br><span class="line">				<span class="comment">// 如果该端口已经被使用</span></span><br><span class="line">				<span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp;</span><br><span class="line">				    tb-&gt;port == port) &#123;</span><br><span class="line">					<span class="keyword">if</span> (tb-&gt;fastreuse &gt;= <span class="number">0</span>)</span><br><span class="line">						<span class="keyword">goto</span> next_port;</span><br><span class="line">					WARN_ON(hlist_empty(&amp;tb-&gt;owners));</span><br><span class="line">					<span class="comment">// 通过 check_established 继续检查是否可用</span></span><br><span class="line">					<span class="keyword">if</span> (!check_established(death_row, sk,</span><br><span class="line">								port, &amp;tw))</span><br><span class="line">						<span class="keyword">goto</span> ok;</span><br><span class="line">					<span class="keyword">goto</span> next_port;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file:net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="comment">// tcp连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_connect</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcp连接初始化</span></span><br><span class="line">	tcp_connect_init(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 申请skb并构造为一个SYN包</span></span><br><span class="line">	buff = alloc_skb_fclone(MAX_TCP_HEADER + <span class="number">15</span>, sk-&gt;sk_allocation);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(buff == <span class="literal">NULL</span>))</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加到发送队列	</span></span><br><span class="line">	__tcp_add_write_queue_tail(sk, buff);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 实际发出syn</span></span><br><span class="line">	err = tcp_transmit_skb(sk, buff, <span class="number">1</span>, sk-&gt;sk_allocation);</span><br><span class="line">	<span class="keyword">if</span> (err == -ECONNREFUSED)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timer for repeating the SYN until an answer. */</span></span><br><span class="line">	<span class="comment">// 启动重传定时器</span></span><br><span class="line">	inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,</span><br><span class="line">				  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>判断四元组</strong></p>
<p>两对四元组中只要任意一个元素不同，都算是两条不同的连接。以下的两条 TCP 连接完全可以同时存在（假设 192.168.1.101 是客户端，192.168.1.100 是服务端）</p>
<ul>
<li>连接1：192.168.0.1 5000 192.168.0.2 8090</li>
<li>连接2：192.168.0.1 5000 192.168.0.2 8091</li>
</ul>
<p>check_established 作用就是检测现有的 TCP 连接中是否四元组和要建立的连接四元素完全一致。如果不完全一致，那么该端口仍然可用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __inet_check_established(struct inet_timewait_death_row *death_row,</span><br><span class="line">				    struct sock *sk, __u16 lport,</span><br><span class="line">				    struct inet_timewait_sock **twp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到hash桶，所有ESTABLISH状态的socket组成的哈希表。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hash = inet_ehashfn(net, daddr, lport,</span><br><span class="line">					 saddr, inet-&gt;inet_dport);</span><br><span class="line"></span><br><span class="line">	spin_lock(lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check TIME-WAIT sockets first. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历查看是否有四元组一样的，一样就报错</span></span><br><span class="line">	sk_nulls_for_each(sk2, node, &amp;head-&gt;twchain) &#123;</span><br><span class="line">		tw = inet_twsk(sk2);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (INET_TW_MATCH(sk2, net, hash, acookie,</span><br><span class="line">					saddr, daddr, ports, dif)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (twsk_unique(sk, sk2, twp))</span><br><span class="line">				<span class="keyword">goto</span> unique;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">goto</span> not_unique;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    tw = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* And established part... */</span></span><br><span class="line">    <span class="comment">// 使用 INET_MATCH 来判断是否可用。</span></span><br><span class="line">	sk_nulls_for_each(sk2, node, &amp;head-&gt;chain) &#123;</span><br><span class="line">		<span class="keyword">if</span> (INET_MATCH(sk2, net, hash, acookie,</span><br><span class="line">					saddr, daddr, ports, dif))</span><br><span class="line">			<span class="keyword">goto</span> not_unique;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">unique:</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">not_unique:</span><br><span class="line">	spin_unlock(lock);</span><br><span class="line">	<span class="keyword">return</span> -EADDRNOTAVAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/inet_hashtables.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_MATCH(__sk, __net, __hash, __cookie, __saddr, __daddr, __ports, __dif)	\</span></span><br><span class="line"><span class="meta">	(((__sk)-&gt;sk_hash == (__hash)) &amp;&amp; net_eq(sock_net(__sk), (__net))	&amp;&amp;	\</span></span><br><span class="line"><span class="meta">	 (inet_sk(__sk)-&gt;inet_daddr	== (__saddr))		&amp;&amp;	\</span></span><br><span class="line"><span class="meta">	 (inet_sk(__sk)-&gt;inet_rcv_saddr	== (__daddr))		&amp;&amp;	\</span></span><br><span class="line"><span class="meta">	 ((*((__portpair *)&amp;(inet_sk(__sk)-&gt;inet_dport))) == (__ports))	&amp;&amp;	\</span></span><br><span class="line"><span class="meta">	 (!((__sk)-&gt;sk_bound_dev_if) || ((__sk)-&gt;sk_bound_dev_if == (__dif))))</span></span><br></pre></td></tr></table></figure>

<p><strong>所以一台客户端机最大能建立的连接数并不是 65535。只要 server 足够多，单机发出百万条连接没有任何问题。</strong></p>
<br>

<h3 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h3><h4 id="服务器响应SYN"><a href="#服务器响应SYN" class="headerlink" title="服务器响应SYN"></a>服务器响应SYN</h4><p>主要工作是判断下接收队列是否满了，满的话可能会丢弃该请求，否则发出 synack。申请 request_sock 添加到半连接队列中，同时启动定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 处理握手过程 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_do_rcv</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果已经建立的TCP连接</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_ESTABLISHED) &#123; <span class="comment">/* Fast path */</span></span><br><span class="line">		sock_rps_save_rxhash(sk, skb-&gt;rxhash);</span><br><span class="line">		<span class="keyword">if</span> (tcp_rcv_established(sk, skb, tcp_hdr(skb), skb-&gt;len)) &#123;</span><br><span class="line">			rsk = sk;</span><br><span class="line">			<span class="keyword">goto</span> reset;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &lt; tcp_hdrlen(skb) || tcp_checksum_complete(skb))</span><br><span class="line">		<span class="keyword">goto</span> csum_err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器收到第一步握手SYN或者第三步ACK都会进入里</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">		<span class="comment">// 进入tcp_v4_hnd_req中查看半连接队列</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nsk</span> =</span> tcp_v4_hnd_req(sk, skb);</span><br><span class="line">		<span class="keyword">if</span> (!nsk)</span><br><span class="line">			<span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nsk != sk) &#123;</span><br><span class="line">			sock_rps_save_rxhash(nsk, skb-&gt;rxhash);</span><br><span class="line">			<span class="keyword">if</span> (tcp_child_process(sk, nsk, skb)) &#123;</span><br><span class="line">				rsk = nsk;</span><br><span class="line">				<span class="keyword">goto</span> reset;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		sock_rps_save_rxhash(sk, skb-&gt;rxhash);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据不同的socket状态进行不同的处理</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb-&gt;len)) &#123;</span><br><span class="line">		rsk = sk;</span><br><span class="line">		<span class="keyword">goto</span> reset;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="comment">// 除了 ESTABLISHED 和 TIME_WAIT，其他状态下的 TCP 处理都走这里</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			  struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次握手或第三次握手，服务器收到ack包</span></span><br><span class="line">	<span class="keyword">case</span> TCP_LISTEN:</span><br><span class="line">		<span class="keyword">if</span> (th-&gt;ack)</span><br><span class="line">			<span class="comment">// 如果是响应包</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;rst)</span><br><span class="line">			<span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">			<span class="comment">// 如果是SYN握手包</span></span><br><span class="line">			<span class="comment">// conn_request是个函数指针，指向tcp_v4_conn_request</span></span><br><span class="line">			<span class="comment">// 服务器响应 SYN 的主要处理逻辑都在这个tcp_v4_conn_request里</span></span><br><span class="line">			<span class="keyword">if</span> (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 响应SYN的主要处理逻辑都在这个方法中</span></span><br><span class="line"><span class="comment">// 1.先判断一下半连接队列是否满了</span></span><br><span class="line"><span class="comment">// 		如果满了就进入tcp_syn_flood_action（syn flood攻击）查看是否开启tcp_syncookies内核参数，没有开启就会丢弃该握手包</span></span><br><span class="line"><span class="comment">// 2.判断全连接队列是否满了</span></span><br><span class="line"><span class="comment">// 		如果满了并且如果有young_ack，直接丢弃</span></span><br><span class="line"><span class="comment">// 		young_ack（未处理完的半连接请求）是半连接队列里保持着的一个计数器。</span></span><br><span class="line"><span class="comment">// 			记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK,</span></span><br><span class="line"><span class="comment">// 			同时也没有完成过三次握手的sock数量</span></span><br><span class="line"><span class="comment">// 3.申请request_sock分配内核对象</span></span><br><span class="line"><span class="comment">// 4.构造syn+ack包并发送响应，tcp_v4_send_synack()方法中。</span></span><br><span class="line"><span class="comment">// 5.添加到半连接队列中并开启计时器重传。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_conn_request</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 判断半连接队列是否满了，如果满了就进入syn_flood_warning去判断是否开启</span></span><br><span class="line">	<span class="comment">// 了 tcp_syncookies 内核参数。</span></span><br><span class="line">	<span class="comment">// 如果队列满，且未开启 tcp_syncookies，那么该握手包将直接被丢弃</span></span><br><span class="line">	<span class="keyword">if</span> (inet_csk_reqsk_queue_is_full(sk) &amp;&amp; !isn) </span><br><span class="line">		<span class="keyword">if</span> (net_ratelimit())</span><br><span class="line">			syn_flood_warning(skb);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在全连接的情况下，如果有young_ack，那么直接丢</span></span><br><span class="line">	<span class="comment">// young_ack 是半连接队列里保持着的一个计数器。</span></span><br><span class="line">	<span class="comment">// 记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK,</span></span><br><span class="line">	<span class="comment">// 同时也没有完成过三次握手的sock数量</span></span><br><span class="line">	<span class="keyword">if</span> (sk_acceptq_is_full(sk) &amp;&amp; inet_csk_reqsk_queue_young(sk) &gt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配request_sock内核对象</span></span><br><span class="line">	req = inet_reqsk_alloc(&amp;tcp_request_sock_ops);</span><br><span class="line">	<span class="keyword">if</span> (!req)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// tcp_v4_send_synack()构造并发送syn+ack响应</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_v4_send_synack(sk, dst, req,</span><br><span class="line">			       (struct request_values *)&amp;tmp_ext) ||</span><br><span class="line">	    want_cookie)</span><br><span class="line">		<span class="keyword">goto</span> drop_and_free;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加到半连接队列，并开启计时器</span></span><br><span class="line">	<span class="comment">// 计时器的作用是在某个时间之内还收不到客户端的第三次握手，</span></span><br><span class="line">	<span class="comment">// 服务器就会重传syn+ack包</span></span><br><span class="line">	inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/tcp_ipv4.c   </span></span><br><span class="line"><span class="comment">// 构造并发送syn + ack</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_v4_send_synack</span><span class="params">(struct sock *sk, struct dst_entry *dst,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct request_values *rvp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造syn + ack包</span></span><br><span class="line">	skb = tcp_make_synack(sk, dst, req, rvp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb) &#123;</span><br><span class="line">        <span class="comment">// 如果构建成功</span></span><br><span class="line">		__tcp_v4_send_check(skb, ireq-&gt;loc_addr, ireq-&gt;rmt_addr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送syn + ack响应</span></span><br><span class="line">		err = ip_build_and_send_pkt(skb, sk, ireq-&gt;loc_addr,</span><br><span class="line">					    ireq-&gt;rmt_addr,</span><br><span class="line">					    ireq-&gt;opt);</span><br><span class="line">		err = net_xmit_eval(err);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst_release(dst);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="客户端响应SYN-ACK"><a href="#客户端响应SYN-ACK" class="headerlink" title="客户端响应SYN + ACK"></a>客户端响应SYN + ACK</h4><p>清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，开启保活计时器后发出第三次握手的 ack 确认。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			  struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 客户端第二次握手处理</span></span><br><span class="line">	<span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line">		<span class="comment">// 处理 syn+ack 包</span></span><br><span class="line">		queued = tcp_rcv_synsent_state_process(sk, skb, th, len);</span><br><span class="line">		<span class="keyword">if</span> (queued &gt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> queued;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do step6 onward by hand. */</span></span><br><span class="line">		tcp_urg(sk, skb, th);</span><br><span class="line">		__kfree_skb(skb);</span><br><span class="line">		tcp_data_snd_check(sk);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_rcv_synsent_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">					 struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;ack) &#123;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 修改socket状态</span></span><br><span class="line">		tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 连接建立完成</span></span><br><span class="line">		security_inet_conn_established(sk, skb);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化拥塞控制</span></span><br><span class="line">		tcp_init_congestion_control(sk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 保活计时器打开</span></span><br><span class="line">		<span class="keyword">if</span> (sock_flag(sk, SOCK_KEEPOPEN))</span><br><span class="line">			inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_write_pending ||</span><br><span class="line">		    icsk-&gt;icsk_accept_queue.rskq_defer_accept ||</span><br><span class="line">		    icsk-&gt;icsk_ack.pingpong) &#123;</span><br><span class="line">			<span class="comment">/* Save one ACK. Data will be ready after</span></span><br><span class="line"><span class="comment">			 * several ticks, if write_pending is set.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * It may be deleted, but with this feature tcpdumps</span></span><br><span class="line"><span class="comment">			 * look so _wonderfully_ clever, that I was not able</span></span><br><span class="line"><span class="comment">			 * to stand against the temptation 8)     --ANK</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 延迟确认</span></span><br><span class="line">			inet_csk_schedule_ack(sk);</span><br><span class="line">			icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span><br><span class="line">			icsk-&gt;icsk_ack.ato	 = TCP_ATO_MIN;</span><br><span class="line">			tcp_incr_quickack(sk);</span><br><span class="line">			tcp_enter_quickack_mode(sk);</span><br><span class="line">			inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,</span><br><span class="line">						  TCP_DELACK_MAX, TCP_RTO_MAX);</span><br><span class="line"></span><br><span class="line">discard:</span><br><span class="line">			__kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 申请构造ack包然后返回响应</span></span><br><span class="line">			tcp_send_ack(sk);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* No ACK in the segment */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;rst) &#123;</span><br><span class="line">		<span class="comment">/* rfc793:</span></span><br><span class="line"><span class="comment">		 * &quot;If the RST bit is set</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *      Otherwise (no ACK) drop the segment and return.&quot;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> discard_and_undo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">		<span class="comment">/* We see SYN without ACK. It is attempt of</span></span><br><span class="line"><span class="comment">		 * simultaneous connect with crossed SYNs.</span></span><br><span class="line"><span class="comment">		 * Particularly, it can be connect to self.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是syn包，就设置socket状态为TCP_SYN_RECV</span></span><br><span class="line">		tcp_set_state(sk, TCP_SYN_RECV);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 序号seq+1</span></span><br><span class="line">		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line">		tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送syn + ack包</span></span><br><span class="line">        tcp_send_synack(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_send_ack</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 申请和构造ack包</span></span><br><span class="line">	buff = alloc_skb(MAX_TCP_HEADER, GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 发送ack包</span></span><br><span class="line">	tcp_transmit_skb(sk, buff, <span class="number">0</span>, GFP_ATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="服务端响应ACK"><a href="#服务端响应ACK" class="headerlink" title="服务端响应ACK"></a>服务端响应ACK</h4><p>把当前半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端第三次握手的ack与第一次握手一样，都会进入到tcp_v4_do_rcv，此时去半连接队列中查看就不是空的了，会保留第一次握手的半连接信息</span></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct sock *<span class="title">tcp_v4_hnd_req</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 查找listen socket的半连接队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span> =</span> inet_csk_search_req(sk, &amp;prev, th-&gt;source,</span><br><span class="line">						       iph-&gt;saddr, iph-&gt;daddr);</span><br><span class="line">	<span class="keyword">if</span> (req)</span><br><span class="line">        <span class="comment">// 如果找到了</span></span><br><span class="line">		<span class="keyword">return</span> tcp_check_req(sk, skb, req, prev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file：net/ipv4/tcp_minisocks.c</span></span><br><span class="line"><span class="comment">// 主要是创建一个子socket，然后清理半连接队列，添加到全连接队列中</span></span><br><span class="line"><span class="function">struct sock *<span class="title">tcp_check_req</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			   struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">			   struct request_sock **prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 创建子socket</span></span><br><span class="line">	<span class="comment">// 对应的是tcp_v4_syn_recv_sock 函数</span></span><br><span class="line">	child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> listen_overflow;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清理半连接队列</span></span><br><span class="line">	inet_csk_reqsk_queue_unlink(sk, req, prev);</span><br><span class="line">	inet_csk_reqsk_queue_removed(sk, req);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加全连接队列</span></span><br><span class="line">	inet_csk_reqsk_queue_add(sk, req, child);</span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 创建sock内核对象</span></span><br><span class="line"><span class="function">struct sock *<span class="title">tcp_v4_syn_recv_sock</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct dst_entry *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断接收队列是否满了，如果满了就修改一下计数器然后丢弃</span></span><br><span class="line">	<span class="keyword">if</span> (sk_acceptq_is_full(sk))</span><br><span class="line">		<span class="keyword">goto</span> exit_overflow;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建sock &amp;&amp; 初始化</span></span><br><span class="line">	newsk = tcp_create_openreq_child(sk, req, skb);</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: include/net/inet_connection_sock.h </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inet_csk_reqsk_queue_unlink</span><span class="params">(struct sock *sk,</span></span></span><br><span class="line"><span class="params"><span class="function">					       struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">					       struct request_sock **prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 把连接请求块从半连接队列中删除</span></span><br><span class="line">	reqsk_queue_unlink(&amp;inet_csk(sk)-&gt;icsk_accept_queue, req, prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/syncookies.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inet_csk_reqsk_queue_add</span><span class="params">(struct sock *sk,</span></span></span><br><span class="line"><span class="params"><span class="function">					    struct request_sock *req,</span></span></span><br><span class="line"><span class="params"><span class="function">					    struct sock *child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 将握手成功的request_sock对象插入到全连接队列链表的尾部</span></span><br><span class="line">	reqsk_queue_add(&amp;inet_csk(sk)-&gt;icsk_accept_queue, req, sk, child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			  struct tcphdr *th, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">		<span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">		<span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line">		<span class="comment">//第三次握手处理</span></span><br><span class="line">			<span class="keyword">if</span> (acceptable) &#123;</span><br><span class="line">				tp-&gt;copied_seq = tp-&gt;rcv_nxt;</span><br><span class="line">				smp_mb();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 修改状态为已连接</span></span><br><span class="line">				tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                </span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<h3 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h3><p><strong>服务端accept：</strong>从已建立好的全连接队列中取第一个返回给用户进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/inet_connection_sock.c</span></span><br><span class="line"><span class="function">struct sock *<span class="title">inet_csk_accept</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> *err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 从全连接队列中获取第一个元素</span></span><br><span class="line">	newsk = reqsk_queue_get_child(&amp;icsk-&gt;icsk_accept_queue, sk);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:include/net/request_sock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct sock *<span class="title">reqsk_queue_get_child</span><span class="params">(struct request_sock_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">						 struct sock *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 从全连接队列中获取第一个元素</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span> =</span> reqsk_queue_remove(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">child</span> =</span> req-&gt;sk;</span><br><span class="line"></span><br><span class="line">	WARN_ON(child == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	sk_acceptq_removed(parent);</span><br><span class="line">	__reqsk_free(req);</span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file:include/net/request_sock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">reqsk_queue_removed</span><span class="params">(struct request_sock_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				      struct request_sock *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listen_sock</span> *<span class="title">lopt</span> =</span> <span class="built_in">queue</span>-&gt;listen_opt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;retrans == <span class="number">0</span>)</span><br><span class="line">		--lopt-&gt;qlen_young;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> --lopt-&gt;qlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>握手前的准备</strong></p>
<ul>
<li>客户端：通过<code>socket()</code>方法获取一个fd文件描述符，通过bind()方法绑定一个端口（可以不调用该方法；如果调用了，首先会判断用户 传入的端口号是否大于1024，然后通过<code>inet_csk_get_port</code>方法判断该端口是否被占用，如果被占用就返回``EADDRINUSE`。只会在bind状态的socket里面查找，不会去ESTABLISH 的哈希表进行可用检测）</li>
<li>服务端：通过<code>socket()</code>方法获取一个fd文件描述符，通过listen()方法初始化连接队列（全连接队列大小 = <code>min(backlog, net.core.somaxconn)</code>，半连接队列大小 = <code>min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再向上取整到 2 的幂次，但最小不能小于16</code>）</li>
</ul>
<p><strong>第一次握手</strong></p>
<ul>
<li>客户端：根据传入的fd文件描述符，找到对应的socket内核对象。调用<code>sock-&gt;ops-&gt;connect</code>方法（<code>inet_stream_connect</code>），然后在<code>tcp_v4_connect()</code>方法中将socket状态设置为<code>TCP_SYN_SENT</code>，通过<code>_inet_hash_connect()</code>方法动态选择一个端口号（首先判断是否<code>bind()</code>了一个端口，如果没有，就<strong>根据目标地址和端口等信息生成一个随机数</strong>，然后在本地端口范围中通过这个随机数逐渐增加遍历，如果是本地配置的保留端口就跳过，如果不是就遍历已经使用的端口的哈希链表（<code>hinfo-&gt;bhash</code>），判断是否已经被使用，如果该端口已经被使用并且<strong>TCP连接中的四元组与当前建立的四元组完全一致</strong>，就不能使用，继续遍历。找到了就返回端口，没找到就提示<code>Address already in use</code>）。通过<code>tcp_connect()</code>构建skb并添加到发送队列<code>sk_write_queue</code>上，启动重传定时器，进行发送。</li>
</ul>
<p><strong>第二次握手</strong></p>
<ul>
<li>服务端：首先会判断半连接队列是否满了，如果满了就进入<code>syn_flood_warning</code>去判断是否开启了 <code>tcp_syncookies</code> 内核参数。如果队列满，且未开启 <code>tcp_syncookies</code>，那么该握手包将直接被丢弃，然后去判断一下全连接队列是否满了，如果满了并且有<code>young_ack</code>，直接丢弃，否则发出 synack。申请<code>request_sock</code> 添加到半连接队列中，同时启动定时器。<code>young_ack</code>（未处理完的半连接请求）是半连接队列里保持着的一个计数器。记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK,同时也没有完成过三次握手的sock数量。</li>
<li>客户端：清除重传定时器，将当前socket状态设置为ESTABLISHED，开启保活计时器后发出ack确认</li>
</ul>
<p><strong>第三次握手</strong></p>
<ul>
<li>服务端：找到半连接队列中的request_sock对象，判断全连接队列是否满了，如果满了就修改计数器然后丢弃，没满就创建新的sock对象，将半连接中的连接请求进行删除，添加到全连接队列中，将状态设置为<code>TCP_ESTABLISHED</code>。</li>
</ul>
<p><strong>最后</strong></p>
<p>调用<code>accept()</code>方法从全连接队列中获取一个返回给用户进程</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Linux中TCP三次握手的实现</p><p><a href="http://zhaommmmomo.cn/2021/07/11/Linux中TCP三次握手的实现/">http://zhaommmmomo.cn/2021/07/11/Linux中TCP三次握手的实现/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>zhaommmmomo</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-07-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Attribution" href="http://zhaommmmomo.cn"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Download on GitHub" href="https://github.com/zhaommmmomo/blog"><i class="icon fab fa-github"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a><a class="link-muted mr-2" rel="tag" href="/tags/TCP/">TCP</a><a class="link-muted mr-2" rel="tag" href="/tags/Linux%E7%BD%91%E7%BB%9C/">Linux网络</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/01/Java%E4%B8%AD%E7%9A%84Thread/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java中的Thread</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/26/SpringMVC%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/"><span class="level-item">SpringMVC大致过程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/logo.jpg" alt="zhaommmmomo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zhaommmmomo</p><p class="is-size-6 is-block">fahaxiki!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Yantai,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://zhaommmmomo.cn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zhaommmmomo"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#TCP三次握手"><span class="level-left"><span class="level-item">2</span><span class="level-item">TCP三次握手</span></span></a></li><li><a class="level is-mobile" href="#Linux中的实现"><span class="level-left"><span class="level-item">3</span><span class="level-item">Linux中的实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#socket"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">socket()</span></span></a></li><li><a class="level is-mobile" href="#bind"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">bind()</span></span></a></li><li><a class="level is-mobile" href="#listen"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">listen()</span></span></a></li><li><a class="level is-mobile" href="#connect"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">connect()</span></span></a></li><li><a class="level is-mobile" href="#recv"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">recv()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#服务器响应SYN"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">服务器响应SYN</span></span></a></li><li><a class="level is-mobile" href="#客户端响应SYN-ACK"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">客户端响应SYN + ACK</span></span></a></li><li><a class="level is-mobile" href="#服务端响应ACK"><span class="level-left"><span class="level-item">3.5.3</span><span class="level-item">服务端响应ACK</span></span></a></li></ul></li><li><a class="level is-mobile" href="#accept"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">accept()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="zmm&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 zhaommmmomo</span>  <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">湘ICP备案2021018362号</a>    <a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43062302000147">湘公网安备43062302000147号</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/zhaommmmomo"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>